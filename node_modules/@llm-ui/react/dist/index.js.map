{"version":3,"sources":["../src/core/useLLMOutput/index.tsx","../src/throttle/basic.ts","../src/core/useLLMOutput/helper.ts","../src/examples/helper.ts","../src/examples/useStreamTokenArray.ts","../src/examples/useStreamWithProbabilities.ts"],"sourcesContent":["import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport { throttleBasic } from \"../../throttle\";\nimport { matchBlocks } from \"./helper\";\nimport {\n  BlockMatch,\n  LLMOutputBlock,\n  LLMOutputFallbackBlock,\n  ThrottleFunction,\n} from \"./types\";\n\nexport type LLMOutputProps = {\n  llmOutput: string;\n  blocks?: LLMOutputBlock[];\n  fallbackBlock: LLMOutputFallbackBlock;\n  isStreamFinished: boolean;\n  throttle?: ThrottleFunction;\n  onFinish?: () => void;\n};\n\nconst matchesToVisibleText = (matches: BlockMatch[]): string => {\n  return matches.map((match) => match.visibleText).join(\"\");\n};\n\nconst matchesToOutput = (matches: BlockMatch[]): string => {\n  return matches.map((match) => match.output).join(\"\");\n};\n\nexport type UseLLMOutputReturn = {\n  blockMatches: BlockMatch[];\n  isFinished: boolean;\n  finishCount: number;\n  visibleText: string;\n  restart: () => void;\n};\n\nconst initialState = {\n  blockMatches: [],\n  isFinished: false,\n  visibleText: \"\",\n};\n\nexport const useLLMOutput = ({\n  llmOutput,\n  isStreamFinished,\n  blocks = [],\n  fallbackBlock,\n  throttle = throttleBasic(),\n  onFinish = () => null,\n}: LLMOutputProps): UseLLMOutputReturn => {\n  const startTime = useRef(performance.now());\n  const lastRenderTime = useRef(performance.now());\n  const renderLoopRef = useRef<(frameTime: DOMHighResTimeStamp) => void>();\n  const frameRef = useRef<number>();\n  const frameCountRef = useRef<number>(0);\n  const finishTimeRef = useRef<DOMHighResTimeStamp>();\n  const previousFrameTimeRef = useRef<DOMHighResTimeStamp>();\n  const visibleTextAllLengthsRef = useRef<number[]>([]);\n  const outputLengthsRef = useRef<number[]>([]);\n  const visibleTextIncrementsRef = useRef<number[]>([]);\n  const visibleTextLengthTargetRef = useRef<number>(0);\n\n  const memoMatchBlocks = useMemo(() => {\n    return matchBlocks({\n      llmOutput,\n      blocks,\n      fallbackBlock,\n      isStreamFinished,\n    });\n  }, [llmOutput, isStreamFinished]);\n\n  const [{ blockMatches, ...state }, setState] = useState<\n    Omit<UseLLMOutputReturn, \"restart\">\n  >({\n    ...initialState,\n    finishCount: 0,\n    blockMatches: memoMatchBlocks,\n  });\n\n  const reset = useCallback(() => {\n    setState((state) => ({ ...state, ...initialState }));\n    startTime.current = performance.now();\n    finishTimeRef.current = undefined;\n    previousFrameTimeRef.current = undefined;\n    visibleTextAllLengthsRef.current = [];\n    outputLengthsRef.current = [];\n    visibleTextIncrementsRef.current = [];\n    visibleTextLengthTargetRef.current = 0;\n    frameCountRef.current = 0;\n    if (frameRef.current) {\n      cancelAnimationFrame(frameRef.current);\n      frameRef.current = undefined;\n    }\n  }, [setState]);\n\n  const restart = useCallback(() => {\n    reset();\n    setTimeout(() => {\n      if (renderLoopRef.current) {\n        frameRef.current = requestAnimationFrame(renderLoopRef.current);\n      }\n    }, 10);\n  }, [reset]);\n\n  const renderLoop = (frameTime: DOMHighResTimeStamp) => {\n    if (!renderLoopRef.current) {\n      return;\n    }\n\n    const allMatches = matchBlocks({\n      llmOutput,\n      blocks,\n      fallbackBlock,\n      isStreamFinished,\n    });\n    const visibleText = matchesToVisibleText(blockMatches);\n    const outputRendered = matchesToOutput(blockMatches);\n\n    const visibleTextAll = matchesToVisibleText(allMatches);\n    const outputAll = matchesToOutput(allMatches);\n    if (!isStreamFinished) {\n      visibleTextAllLengthsRef.current.push(visibleTextAll.length);\n      outputLengthsRef.current.push(outputAll.length);\n    }\n    const isFinished = visibleText === visibleTextAll && isStreamFinished;\n    if (isFinished) {\n      frameRef.current = undefined;\n      setState((state) => ({\n        ...state,\n        blockMatches,\n        isFinished,\n        finishCount: state.finishCount + 1,\n        visibleText,\n      }));\n      onFinish();\n      return;\n    }\n\n    // make sure throttle has the last text lengths when the stream finishes\n    const visibleTextLengthsAll = isStreamFinished\n      ? [...visibleTextAllLengthsRef.current, visibleTextAll.length]\n      : visibleTextAllLengthsRef.current;\n\n    const outputLengths = isStreamFinished\n      ? [...outputLengthsRef.current, outputAll.length]\n      : outputLengthsRef.current;\n\n    const { visibleTextIncrement } = throttle({\n      outputRaw: llmOutput,\n      outputRendered,\n      outputAll,\n      visibleText,\n      visibleTextAll,\n      startStreamTime: startTime.current,\n      isStreamFinished,\n      frameCount: frameCountRef.current,\n      frameTime,\n      frameTimePrevious: previousFrameTimeRef.current,\n      finishStreamTime: finishTimeRef.current,\n      visibleTextLengthsAll,\n      outputLengths,\n      visibleTextIncrements: visibleTextIncrementsRef.current,\n      visibleTextLengthTarget: visibleTextLengthTargetRef.current,\n    });\n    if (visibleTextIncrement < 0) {\n      throw new Error(\"throttle returned negative visibleTextIncrement\");\n    }\n\n    visibleTextIncrementsRef.current.push(visibleTextIncrement);\n    visibleTextLengthTargetRef.current =\n      visibleTextLengthTargetRef.current + visibleTextIncrement;\n\n    if (visibleTextLengthTargetRef.current > visibleText.length) {\n      const matches = matchBlocks({\n        llmOutput,\n        blocks,\n        fallbackBlock,\n        isStreamFinished,\n        visibleTextLengthTarget: visibleTextLengthTargetRef.current,\n      });\n      const updatedVisibleText = matchesToVisibleText(matches);\n\n      lastRenderTime.current = performance.now();\n\n      setState((state) => ({\n        ...state,\n        blockMatches: matches,\n        isFinished,\n        visibleText: updatedVisibleText,\n      }));\n    }\n    frameRef.current = requestAnimationFrame(renderLoopRef.current);\n    previousFrameTimeRef.current = frameTime;\n    frameCountRef.current = frameCountRef.current + 1;\n  };\n\n  useEffect(() => {\n    renderLoopRef.current = renderLoop;\n  });\n\n  useEffect(() => {\n    renderLoopRef.current = renderLoop;\n    // start the render loop\n    if (!frameRef.current && llmOutput && llmOutput.length > 0) {\n      frameRef.current = requestAnimationFrame(renderLoopRef.current);\n    } else if (\n      // reset the render loop if user clears the llmOutput\n      visibleTextIncrementsRef.current.length > 0 &&\n      llmOutput.length === 0\n    ) {\n      reset();\n    }\n  }, [llmOutput]);\n\n  useEffect(() => {\n    () => {\n      if (frameRef.current) {\n        cancelAnimationFrame(frameRef.current);\n      }\n    };\n  }, []);\n\n  useEffect(() => {\n    if (!finishTimeRef.current && isStreamFinished) {\n      finishTimeRef.current = performance.now();\n    }\n  }, [isStreamFinished]);\n\n  return { blockMatches, restart, ...state };\n};\n","import type { ThrottleFunction } from \"../core\";\n\nexport type ThrottleBasicOptions = {\n  readAheadChars: number;\n  targetBufferChars: number;\n  adjustPercentage: number;\n  frameLookBackMs: number;\n  windowLookBackMs: number;\n};\n\nexport const defaultOptions: ThrottleBasicOptions = {\n  readAheadChars: 15,\n  targetBufferChars: 15,\n  adjustPercentage: 0.2,\n  frameLookBackMs: 10000,\n  windowLookBackMs: 2000,\n};\n\nconst calcPercentage = ({\n  isBehind,\n  adjustPercentage,\n  isStreamFinished,\n}: {\n  isBehind: boolean;\n  adjustPercentage: number;\n  isStreamFinished: boolean;\n}) => {\n  if (isStreamFinished) {\n    return 1;\n  }\n  if (isBehind) {\n    return 1 - adjustPercentage;\n  }\n  return 1 + adjustPercentage;\n};\n\nconst getVisibleTextEveryNFrames = (\n  lookbackFrameCount: number,\n  windowLookBackCount: number,\n  visibleTextLengthsAllOriginal: number[],\n) => {\n  const visibleTextLengthsAll = [0, ...visibleTextLengthsAllOriginal];\n  const lookbackFrames = Math.min(\n    lookbackFrameCount,\n    visibleTextLengthsAll.length,\n  );\n  const windowFrames = Math.min(\n    windowLookBackCount,\n    visibleTextLengthsAll.length,\n  );\n  const recentVisibleTextLengths = visibleTextLengthsAll.slice(\n    -1 * lookbackFrames,\n  );\n\n  const textAddedCounts = [];\n\n  if (windowFrames > 0) {\n    for (\n      let start = 0;\n      start < recentVisibleTextLengths.length - windowFrames + 1;\n      start++\n    ) {\n      const end = start + windowFrames - 1;\n      const textAddedCount =\n        recentVisibleTextLengths[end] - recentVisibleTextLengths[start];\n      textAddedCounts.push(textAddedCount);\n    }\n  }\n\n  const avgTextAddedCount =\n    textAddedCounts.reduce((a, b) => a + b, 0) / textAddedCounts.length ?? 0;\n  const result =\n    avgTextAddedCount > 0 ? windowFrames / avgTextAddedCount : windowFrames;\n\n  return result;\n};\n\nexport const throttleBasic = (\n  userOptions: Partial<ThrottleBasicOptions> = {},\n): ThrottleFunction => {\n  const {\n    frameLookBackMs,\n    targetBufferChars,\n    readAheadChars,\n    adjustPercentage,\n    windowLookBackMs,\n  } = {\n    ...defaultOptions,\n    ...userOptions,\n  };\n  return ({\n    visibleText,\n    isStreamFinished,\n    visibleTextAll,\n    visibleTextLengthsAll,\n    frameCount,\n    visibleTextIncrements,\n    visibleTextLengthTarget,\n    startStreamTime,\n  }) => {\n    const timeSinceStartMs = performance.now() - startStreamTime;\n    const timeSinceStartSec = timeSinceStartMs / 1000;\n    const fps = frameCount / timeSinceStartSec;\n\n    const bufferSize = visibleTextAll.length - visibleTextLengthTarget;\n    const lookbackFrameCount = Math.ceil(frameLookBackMs / (1000 / fps));\n    const windowLookBackCount = Math.ceil(windowLookBackMs / (1000 / fps));\n\n    const visibleTextEveryNFrames = getVisibleTextEveryNFrames(\n      lookbackFrameCount,\n      windowLookBackCount,\n      visibleTextLengthsAll,\n    );\n\n    let framesSinceLastIncrement = [...visibleTextIncrements]\n      .reverse()\n      .findIndex((inc) => inc > 0);\n    framesSinceLastIncrement =\n      framesSinceLastIncrement === -1 ? frameCount : framesSinceLastIncrement;\n    let visibleTextIncrement = 0;\n    const targetBufferSize = readAheadChars + targetBufferChars;\n    if (\n      (!isStreamFinished &&\n        (bufferSize < readAheadChars ||\n          (visibleText.length === 0 && bufferSize < targetBufferSize))) ||\n      visibleTextLengthTarget >= visibleTextAll.length\n    ) {\n      visibleTextIncrement = 0;\n    } else {\n      const targetBufferSize = readAheadChars + targetBufferChars;\n      const isBehind = bufferSize > targetBufferSize;\n\n      const targetFrameEveryN =\n        visibleTextEveryNFrames *\n        calcPercentage({ adjustPercentage, isBehind, isStreamFinished });\n      if (targetFrameEveryN > 1) {\n        visibleTextIncrement =\n          framesSinceLastIncrement >= targetFrameEveryN ? 1 : 0;\n      } else {\n        visibleTextIncrement = Math.round(1 / targetFrameEveryN);\n      }\n    }\n    return {\n      visibleTextIncrement,\n    };\n  };\n};\n","import {\n  BlockMatch,\n  BlockMatchNoLookback,\n  LLMOutputBlock,\n  LLMOutputFallbackBlock,\n  LLMOutputMatch,\n} from \"./types\";\n\nconst completeMatchesForBlock = ({\n  llmOutput,\n  block,\n  priority,\n}: {\n  llmOutput: string;\n  block: LLMOutputBlock;\n  priority: number;\n}): BlockMatchNoLookback[] => {\n  const matches: BlockMatchNoLookback[] = [];\n  let index = 0;\n  while (index < llmOutput.length) {\n    const nextMatch = block.findCompleteMatch(llmOutput.slice(index));\n    if (nextMatch) {\n      matches.push({\n        block,\n        match: {\n          outputRaw: nextMatch.outputRaw,\n          startIndex: index + nextMatch.startIndex,\n          endIndex: index + nextMatch.endIndex,\n        },\n        llmOutput,\n        isComplete: true,\n        priority,\n      });\n      index += nextMatch.endIndex;\n    } else {\n      return matches;\n    }\n  }\n  return matches;\n};\n\nconst highestPriorityNonOverlappingMatches = (\n  matches: BlockMatchNoLookback[],\n): BlockMatchNoLookback[] => {\n  return matches.filter((match) => {\n    const higherPriorityMatches = matches.filter(\n      (m) => m.priority < match.priority,\n    );\n    return !higherPriorityMatches.some((m) =>\n      isOverlapping(m.match, match.match),\n    );\n  });\n};\n\nconst byMatchStartIndex = (\n  match1: BlockMatchNoLookback,\n  match2: BlockMatchNoLookback,\n): number => match1.match.startIndex - match2.match.startIndex;\n\nconst isOverlapping = (\n  match1: LLMOutputMatch,\n  match2: LLMOutputMatch,\n): boolean => {\n  return (\n    (match1.startIndex >= match2.startIndex &&\n      match1.startIndex < match2.endIndex) || // match1 starts inside match2\n    (match1.endIndex > match2.startIndex &&\n      match1.endIndex <= match2.endIndex) || // match1 ends inside match2\n    (match2.startIndex >= match1.startIndex &&\n      match2.startIndex < match1.endIndex) || // match2 starts inside match1\n    (match2.endIndex > match1.startIndex && match2.endIndex <= match1.endIndex) // match2 ends inside match1\n  );\n};\n\nconst findPartialMatch = ({\n  llmOutput,\n  blocks,\n  currentIndex,\n}: {\n  llmOutput: string;\n  currentIndex: number;\n  blocks: LLMOutputBlock[];\n}): BlockMatchNoLookback | undefined => {\n  for (const [priority, block] of Array.from(blocks.entries())) {\n    const outputRaw = llmOutput.slice(currentIndex);\n    const partialMatch = block.findPartialMatch(outputRaw);\n    if (partialMatch) {\n      return {\n        block: block,\n        match: {\n          outputRaw: partialMatch.outputRaw,\n          startIndex: partialMatch.startIndex + currentIndex,\n          endIndex: partialMatch.endIndex + currentIndex,\n        },\n        llmOutput,\n        isComplete: true,\n        priority,\n      };\n    }\n  }\n  return undefined;\n};\n\nexport type FallbacksInGapsParams = {\n  blockMatches: BlockMatchNoLookback[];\n  llmOutput: string;\n  fallbackPriority: number;\n  fallbackBlock: LLMOutputFallbackBlock;\n};\nconst fallbacksInGaps = ({\n  blockMatches,\n  llmOutput,\n  fallbackPriority,\n  fallbackBlock,\n}: FallbacksInGapsParams): BlockMatchNoLookback[] => {\n  const fallbacks = blockMatches\n    .map((match, index) => {\n      const previousMatchEndIndex =\n        index === 0 ? 0 : blockMatches[index - 1].match.endIndex;\n      if (previousMatchEndIndex < match.match.startIndex) {\n        const outputRaw = llmOutput.slice(\n          previousMatchEndIndex,\n          match.match.startIndex,\n        );\n\n        return {\n          block: fallbackBlock,\n          match: {\n            startIndex: previousMatchEndIndex,\n            endIndex: match.match.startIndex,\n            outputRaw,\n          },\n          priority: fallbackPriority,\n          llmOutput,\n          isComplete: true,\n        } satisfies BlockMatchNoLookback;\n      }\n      return undefined;\n    })\n    .filter((match) => match !== undefined) as BlockMatchNoLookback[];\n\n  // Add last fallback that reaches to end of output\n  const lastMatchEndIndex =\n    blockMatches.length > 0\n      ? blockMatches[blockMatches.length - 1].match.endIndex\n      : 0;\n\n  if (lastMatchEndIndex < llmOutput.length) {\n    const outputRaw = llmOutput.slice(lastMatchEndIndex, llmOutput.length);\n\n    fallbacks.push({\n      block: fallbackBlock,\n      match: {\n        startIndex: lastMatchEndIndex,\n        endIndex: llmOutput.length,\n        outputRaw,\n      },\n      priority: fallbackPriority,\n      llmOutput,\n      isComplete: false,\n    });\n  }\n  return fallbacks;\n};\n\nconst matchesWithLookback = ({\n  llmOutputRaw,\n  matches,\n  visibleTextLengthTarget,\n  isStreamFinished,\n}: {\n  llmOutputRaw: string;\n  matches: BlockMatchNoLookback[];\n  visibleTextLengthTarget: number;\n  isStreamFinished: boolean;\n}): BlockMatch[] => {\n  return matches.reduce((acc, match, index) => {\n    const visibleTextSoFar = acc\n      .map((m) => m.visibleText.length)\n      .reduce((a, b) => a + b, 0);\n    const localVisibleTextLengthTarget = Math.max(\n      visibleTextLengthTarget - visibleTextSoFar,\n      0,\n    );\n\n    const isLastMatch = index === matches.length - 1;\n    const isComplete = !isLastMatch || isStreamFinished;\n    const { output, visibleText } = match.block.lookBack({\n      isComplete,\n      visibleTextLengthTarget: localVisibleTextLengthTarget,\n      isStreamFinished: isStreamFinished,\n      output: match.match.outputRaw,\n    });\n    if (\n      visibleText.length > localVisibleTextLengthTarget &&\n      process.env.NODE_ENV === \"development\"\n    ) {\n      console.warn(\n        `Visible text length exceeded target for: ${visibleText} has length ${visibleText.length} target: ${localVisibleTextLengthTarget}. Raw output: ${llmOutputRaw}`,\n      );\n    }\n    const matchWithLookback: BlockMatch = {\n      ...match.match,\n      isComplete,\n      block: match.block,\n      priority: match.priority,\n      llmOutput: match.llmOutput,\n      output,\n      visibleText,\n      isVisible: visibleText.length > 0,\n    };\n\n    return [...acc, matchWithLookback];\n  }, [] as BlockMatch[]);\n};\n\nexport type MatchBlocksParams = {\n  llmOutput: string;\n  blocks: LLMOutputBlock[];\n  fallbackBlock: LLMOutputFallbackBlock;\n  isStreamFinished: boolean;\n  visibleTextLengthTarget?: number;\n};\n\nexport const matchBlocks = ({\n  llmOutput,\n  blocks,\n  fallbackBlock,\n  isStreamFinished,\n  visibleTextLengthTarget = Number.MAX_SAFE_INTEGER,\n}: MatchBlocksParams): BlockMatch[] => {\n  const allCompleteMatches = blocks.flatMap((block, priority) =>\n    completeMatchesForBlock({\n      llmOutput,\n      block,\n      priority,\n    }),\n  );\n  const matches = highestPriorityNonOverlappingMatches(allCompleteMatches);\n  matches.sort(byMatchStartIndex);\n\n  const lastMatchEndIndex =\n    matches.length > 0 ? matches[matches.length - 1].match.endIndex : 0;\n\n  const partialMatch = !isStreamFinished\n    ? findPartialMatch({\n        llmOutput,\n        currentIndex: lastMatchEndIndex,\n        blocks,\n      })\n    : undefined;\n\n  if (partialMatch) {\n    matches.push(partialMatch);\n  }\n  const fallBacks = fallbacksInGaps({\n    blockMatches: matches,\n    llmOutput,\n    fallbackPriority: blocks.length,\n    fallbackBlock,\n  });\n\n  for (const fallBack of fallBacks) {\n    matches.push(fallBack);\n  }\n  matches.sort(byMatchStartIndex);\n  return matchesWithLookback({\n    llmOutputRaw: llmOutput,\n    matches,\n    isStreamFinished,\n    visibleTextLengthTarget,\n  });\n};\n","import { Probability, ProbabilityOptions, TokenWithDelay } from \"./types\";\n\nexport const cumulativeProbability = <T extends Probability>(\n  probs: T[],\n): T[] => {\n  return probs.reduce((acc, curr) => {\n    const previousProb = acc.length === 0 ? 0 : acc[acc.length - 1].prob;\n    return [\n      ...acc,\n      {\n        ...curr,\n        prob: previousProb + curr.prob,\n      },\n    ];\n  }, [] as T[]);\n};\n\nexport const stringToTokenArray = (\n  llmOutput: string,\n  { tokenCharsProbabilities, delayMsProbabilities }: ProbabilityOptions,\n): TokenWithDelay[] => {\n  const tokenCharsProbabilitiesCum = cumulativeProbability(\n    tokenCharsProbabilities,\n  );\n  const delayProbsCum = cumulativeProbability(delayMsProbabilities);\n  let index = 0;\n  const tokensWithDelay: TokenWithDelay[] = [];\n  while (index < llmOutput.length) {\n    const tokenSizeRand = Math.random();\n    const delayRand = Math.random();\n    const remainingChars = llmOutput.length - index;\n\n    const tokenSize = Math.min(\n      tokenCharsProbabilitiesCum.find((tp) => tp.prob > tokenSizeRand)\n        ?.tokenChars ?? 1,\n      remainingChars,\n    );\n\n    const token = llmOutput.slice(index, index + tokenSize);\n    const delay =\n      delayProbsCum.find((dp) => dp.prob > delayRand)?.delayMs ?? 10;\n\n    tokensWithDelay.push({ token, delayMs: delay });\n    index += tokenSize;\n  }\n  return tokensWithDelay;\n};\n","import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport {\n  TokenWithDelay,\n  UseStreamResponse,\n  UseStreamTokenArrayOptions,\n} from \"./types\";\n\nexport const useStreamTokenArrayOptionsDefaultOptions: UseStreamTokenArrayOptions =\n  {\n    autoStartDelayMs: 0,\n    autoStart: true,\n    delayMultiplier: 1,\n    startIndex: 0,\n  };\n\nexport const useStreamTokenArray = (\n  tokenArray: TokenWithDelay[],\n  userOptions?: Partial<UseStreamTokenArrayOptions>,\n): UseStreamResponse => {\n  const nextTokenRef = useRef<() => void>();\n  const options: UseStreamTokenArrayOptions = useMemo(\n    () => ({\n      ...useStreamTokenArrayOptionsDefaultOptions,\n      ...(userOptions ?? {}),\n    }),\n    [userOptions],\n  );\n  const currentIndex = useRef<number>(\n    Math.min(options.startIndex, tokenArray.length),\n  );\n  const [output, setOutput] = useState<string>(\n    tokenArray\n      .slice(0, currentIndex.current)\n      .map((t) => t.token)\n      .join(\"\"),\n  );\n  const [isPlaying, setIsPlaying] = useState<boolean>(options.autoStart);\n\n  const clearTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  const pause = useCallback(() => {\n    if (clearTimeoutRef.current) {\n      clearTimeout(clearTimeoutRef.current);\n      clearTimeoutRef.current = null;\n    }\n    setIsPlaying(false);\n  }, []);\n\n  const reset = useCallback(() => {\n    setOutput(\"\");\n    pause();\n    currentIndex.current = 0;\n  }, []);\n\n  const nextToken = useCallback(async () => {\n    if (!nextTokenRef.current) {\n      return;\n    }\n    const index = currentIndex.current;\n    const isFinished = index >= tokenArray.length;\n    if (isFinished) {\n      setIsPlaying(false);\n      clearTimeoutRef.current = null;\n    } else {\n      const { token, delayMs } = tokenArray[index];\n      setOutput((prevOutput) => `${prevOutput}${token}`);\n      currentIndex.current = index + 1;\n      clearTimeoutRef.current = setTimeout(\n        nextTokenRef.current,\n        delayMs * options.delayMultiplier,\n      );\n    }\n  }, [options, setOutput, reset, tokenArray]);\n\n  useEffect(() => {\n    nextTokenRef.current = nextToken;\n  });\n\n  const start = useCallback(() => {\n    if (clearTimeoutRef.current) {\n      return;\n    }\n    setIsPlaying(true);\n    nextToken();\n  }, [tokenArray, currentIndex]);\n\n  useEffect(() => {\n    if (options.autoStart) {\n      setTimeout(start, options.autoStartDelayMs);\n    }\n  }, []);\n\n  const finishedOutput = tokenArray.map((t) => t.token).join(\"\");\n  const isFinished = output.length === finishedOutput.length;\n  return {\n    output,\n    reset,\n    pause,\n    start,\n    isPlaying,\n    isStreamStarted: output.length > 0,\n    isStreamFinished: isFinished,\n  };\n};\n","import { useMemo, useRef } from \"react\";\nimport { stringToTokenArray } from \"./helper\";\nimport {\n  TokenWithDelay,\n  UseStreamResponse,\n  UseStreamWithProbabilitiesOptions,\n} from \"./types\";\nimport {\n  useStreamTokenArray,\n  useStreamTokenArrayOptionsDefaultOptions,\n} from \"./useStreamTokenArray\";\n\nexport const useStreamWithProbabilitiesDefaultOptions: UseStreamWithProbabilitiesOptions =\n  {\n    delayMsProbabilities: [\n      { delayMs: 10, prob: 0.4 },\n      { delayMs: 70, prob: 0.3 },\n      { delayMs: 250, prob: 0.2 },\n      { delayMs: 600, prob: 0.1 },\n    ],\n    tokenCharsProbabilities: [\n      { tokenChars: 1, prob: 0.5 },\n      { tokenChars: 2, prob: 0.3 },\n      { tokenChars: 3, prob: 0.2 },\n    ],\n    ...useStreamTokenArrayOptionsDefaultOptions,\n  };\n\nexport const useStreamWithProbabilities = (\n  output: string,\n  userOptions?: Partial<UseStreamWithProbabilitiesOptions>,\n): UseStreamResponse => {\n  const options: UseStreamWithProbabilitiesOptions = useMemo(\n    () => ({\n      ...useStreamWithProbabilitiesDefaultOptions,\n      ...(userOptions ?? {}),\n    }),\n    [userOptions],\n  );\n  const tokenArrayRef = useRef<TokenWithDelay[]>(\n    stringToTokenArray(output, options),\n  );\n\n  return useStreamTokenArray(tokenArrayRef.current, options);\n};\n"],"mappings":"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","names":["targetBufferSize","state","useCallback","useEffect","useMemo","useRef","useState","isFinished","useMemo","useRef","useMemo","useRef"]}