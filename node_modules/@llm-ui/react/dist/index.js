// src/core/useLLMOutput/index.tsx
import { useCallback, useEffect, useMemo, useRef, useState } from "react";

// src/throttle/basic.ts
var defaultOptions = {
  readAheadChars: 15,
  targetBufferChars: 15,
  adjustPercentage: 0.2,
  frameLookBackMs: 1e4,
  windowLookBackMs: 2e3
};
var calcPercentage = ({
  isBehind,
  adjustPercentage,
  isStreamFinished
}) => {
  if (isStreamFinished) {
    return 1;
  }
  if (isBehind) {
    return 1 - adjustPercentage;
  }
  return 1 + adjustPercentage;
};
var getVisibleTextEveryNFrames = (lookbackFrameCount, windowLookBackCount, visibleTextLengthsAllOriginal) => {
  const visibleTextLengthsAll = [0, ...visibleTextLengthsAllOriginal];
  const lookbackFrames = Math.min(
    lookbackFrameCount,
    visibleTextLengthsAll.length
  );
  const windowFrames = Math.min(
    windowLookBackCount,
    visibleTextLengthsAll.length
  );
  const recentVisibleTextLengths = visibleTextLengthsAll.slice(
    -1 * lookbackFrames
  );
  const textAddedCounts = [];
  if (windowFrames > 0) {
    for (let start = 0; start < recentVisibleTextLengths.length - windowFrames + 1; start++) {
      const end = start + windowFrames - 1;
      const textAddedCount = recentVisibleTextLengths[end] - recentVisibleTextLengths[start];
      textAddedCounts.push(textAddedCount);
    }
  }
  const avgTextAddedCount = textAddedCounts.reduce((a, b) => a + b, 0) / textAddedCounts.length;
  const result = avgTextAddedCount > 0 ? windowFrames / avgTextAddedCount : windowFrames;
  return result;
};
var throttleBasic = (userOptions = {}) => {
  const {
    frameLookBackMs,
    targetBufferChars,
    readAheadChars,
    adjustPercentage,
    windowLookBackMs
  } = {
    ...defaultOptions,
    ...userOptions
  };
  return ({
    visibleText,
    isStreamFinished,
    visibleTextAll,
    visibleTextLengthsAll,
    frameCount,
    visibleTextIncrements,
    visibleTextLengthTarget,
    startStreamTime
  }) => {
    const timeSinceStartMs = performance.now() - startStreamTime;
    const timeSinceStartSec = timeSinceStartMs / 1e3;
    const fps = frameCount / timeSinceStartSec;
    const bufferSize = visibleTextAll.length - visibleTextLengthTarget;
    const lookbackFrameCount = Math.ceil(frameLookBackMs / (1e3 / fps));
    const windowLookBackCount = Math.ceil(windowLookBackMs / (1e3 / fps));
    const visibleTextEveryNFrames = getVisibleTextEveryNFrames(
      lookbackFrameCount,
      windowLookBackCount,
      visibleTextLengthsAll
    );
    let framesSinceLastIncrement = [...visibleTextIncrements].reverse().findIndex((inc) => inc > 0);
    framesSinceLastIncrement = framesSinceLastIncrement === -1 ? frameCount : framesSinceLastIncrement;
    let visibleTextIncrement = 0;
    const targetBufferSize = readAheadChars + targetBufferChars;
    if (!isStreamFinished && (bufferSize < readAheadChars || visibleText.length === 0 && bufferSize < targetBufferSize) || visibleTextLengthTarget >= visibleTextAll.length) {
      visibleTextIncrement = 0;
    } else {
      const targetBufferSize2 = readAheadChars + targetBufferChars;
      const isBehind = bufferSize > targetBufferSize2;
      const targetFrameEveryN = visibleTextEveryNFrames * calcPercentage({ adjustPercentage, isBehind, isStreamFinished });
      if (targetFrameEveryN > 1) {
        visibleTextIncrement = framesSinceLastIncrement >= targetFrameEveryN ? 1 : 0;
      } else {
        visibleTextIncrement = Math.round(1 / targetFrameEveryN);
      }
    }
    return {
      visibleTextIncrement
    };
  };
};

// src/core/useLLMOutput/helper.ts
var completeMatchesForBlock = ({
  llmOutput,
  block,
  priority
}) => {
  const matches = [];
  let index = 0;
  while (index < llmOutput.length) {
    const nextMatch = block.findCompleteMatch(llmOutput.slice(index));
    if (nextMatch) {
      matches.push({
        block,
        match: {
          outputRaw: nextMatch.outputRaw,
          startIndex: index + nextMatch.startIndex,
          endIndex: index + nextMatch.endIndex
        },
        llmOutput,
        isComplete: true,
        priority
      });
      index += nextMatch.endIndex;
    } else {
      return matches;
    }
  }
  return matches;
};
var highestPriorityNonOverlappingMatches = (matches) => {
  return matches.filter((match) => {
    const higherPriorityMatches = matches.filter(
      (m) => m.priority < match.priority
    );
    return !higherPriorityMatches.some(
      (m) => isOverlapping(m.match, match.match)
    );
  });
};
var byMatchStartIndex = (match1, match2) => match1.match.startIndex - match2.match.startIndex;
var isOverlapping = (match1, match2) => {
  return match1.startIndex >= match2.startIndex && match1.startIndex < match2.endIndex || // match1 starts inside match2
  match1.endIndex > match2.startIndex && match1.endIndex <= match2.endIndex || // match1 ends inside match2
  match2.startIndex >= match1.startIndex && match2.startIndex < match1.endIndex || // match2 starts inside match1
  match2.endIndex > match1.startIndex && match2.endIndex <= match1.endIndex;
};
var findPartialMatch = ({
  llmOutput,
  blocks,
  currentIndex
}) => {
  for (const [priority, block] of Array.from(blocks.entries())) {
    const outputRaw = llmOutput.slice(currentIndex);
    const partialMatch = block.findPartialMatch(outputRaw);
    if (partialMatch) {
      return {
        block,
        match: {
          outputRaw: partialMatch.outputRaw,
          startIndex: partialMatch.startIndex + currentIndex,
          endIndex: partialMatch.endIndex + currentIndex
        },
        llmOutput,
        isComplete: true,
        priority
      };
    }
  }
  return void 0;
};
var fallbacksInGaps = ({
  blockMatches,
  llmOutput,
  fallbackPriority,
  fallbackBlock
}) => {
  const fallbacks = blockMatches.map((match, index) => {
    const previousMatchEndIndex = index === 0 ? 0 : blockMatches[index - 1].match.endIndex;
    if (previousMatchEndIndex < match.match.startIndex) {
      const outputRaw = llmOutput.slice(
        previousMatchEndIndex,
        match.match.startIndex
      );
      return {
        block: fallbackBlock,
        match: {
          startIndex: previousMatchEndIndex,
          endIndex: match.match.startIndex,
          outputRaw
        },
        priority: fallbackPriority,
        llmOutput,
        isComplete: true
      };
    }
    return void 0;
  }).filter((match) => match !== void 0);
  const lastMatchEndIndex = blockMatches.length > 0 ? blockMatches[blockMatches.length - 1].match.endIndex : 0;
  if (lastMatchEndIndex < llmOutput.length) {
    const outputRaw = llmOutput.slice(lastMatchEndIndex, llmOutput.length);
    fallbacks.push({
      block: fallbackBlock,
      match: {
        startIndex: lastMatchEndIndex,
        endIndex: llmOutput.length,
        outputRaw
      },
      priority: fallbackPriority,
      llmOutput,
      isComplete: false
    });
  }
  return fallbacks;
};
var matchesWithLookback = ({
  llmOutputRaw,
  matches,
  visibleTextLengthTarget,
  isStreamFinished
}) => {
  return matches.reduce((acc, match, index) => {
    const visibleTextSoFar = acc.map((m) => m.visibleText.length).reduce((a, b) => a + b, 0);
    const localVisibleTextLengthTarget = Math.max(
      visibleTextLengthTarget - visibleTextSoFar,
      0
    );
    const isLastMatch = index === matches.length - 1;
    const isComplete = !isLastMatch || isStreamFinished;
    const { output, visibleText } = match.block.lookBack({
      isComplete,
      visibleTextLengthTarget: localVisibleTextLengthTarget,
      isStreamFinished,
      output: match.match.outputRaw
    });
    if (visibleText.length > localVisibleTextLengthTarget && process.env.NODE_ENV === "development") {
      console.warn(
        `Visible text length exceeded target for: ${visibleText} has length ${visibleText.length} target: ${localVisibleTextLengthTarget}. Raw output: ${llmOutputRaw}`
      );
    }
    const matchWithLookback = {
      ...match.match,
      isComplete,
      block: match.block,
      priority: match.priority,
      llmOutput: match.llmOutput,
      output,
      visibleText,
      isVisible: visibleText.length > 0
    };
    return [...acc, matchWithLookback];
  }, []);
};
var matchBlocks = ({
  llmOutput,
  blocks,
  fallbackBlock,
  isStreamFinished,
  visibleTextLengthTarget = Number.MAX_SAFE_INTEGER
}) => {
  const allCompleteMatches = blocks.flatMap(
    (block, priority) => completeMatchesForBlock({
      llmOutput,
      block,
      priority
    })
  );
  const matches = highestPriorityNonOverlappingMatches(allCompleteMatches);
  matches.sort(byMatchStartIndex);
  const lastMatchEndIndex = matches.length > 0 ? matches[matches.length - 1].match.endIndex : 0;
  const partialMatch = !isStreamFinished ? findPartialMatch({
    llmOutput,
    currentIndex: lastMatchEndIndex,
    blocks
  }) : void 0;
  if (partialMatch) {
    matches.push(partialMatch);
  }
  const fallBacks = fallbacksInGaps({
    blockMatches: matches,
    llmOutput,
    fallbackPriority: blocks.length,
    fallbackBlock
  });
  for (const fallBack of fallBacks) {
    matches.push(fallBack);
  }
  matches.sort(byMatchStartIndex);
  return matchesWithLookback({
    llmOutputRaw: llmOutput,
    matches,
    isStreamFinished,
    visibleTextLengthTarget
  });
};

// src/core/useLLMOutput/index.tsx
var matchesToVisibleText = (matches) => {
  return matches.map((match) => match.visibleText).join("");
};
var matchesToOutput = (matches) => {
  return matches.map((match) => match.output).join("");
};
var initialState = {
  blockMatches: [],
  isFinished: false,
  visibleText: ""
};
var useLLMOutput = ({
  llmOutput,
  isStreamFinished,
  blocks = [],
  fallbackBlock,
  throttle = throttleBasic(),
  onFinish = () => null
}) => {
  const startTime = useRef(performance.now());
  const lastRenderTime = useRef(performance.now());
  const renderLoopRef = useRef();
  const frameRef = useRef();
  const frameCountRef = useRef(0);
  const finishTimeRef = useRef();
  const previousFrameTimeRef = useRef();
  const visibleTextAllLengthsRef = useRef([]);
  const outputLengthsRef = useRef([]);
  const visibleTextIncrementsRef = useRef([]);
  const visibleTextLengthTargetRef = useRef(0);
  const memoMatchBlocks = useMemo(() => {
    return matchBlocks({
      llmOutput,
      blocks,
      fallbackBlock,
      isStreamFinished
    });
  }, [llmOutput, isStreamFinished]);
  const [{ blockMatches, ...state }, setState] = useState({
    ...initialState,
    finishCount: 0,
    blockMatches: memoMatchBlocks
  });
  const reset = useCallback(() => {
    setState((state2) => ({ ...state2, ...initialState }));
    startTime.current = performance.now();
    finishTimeRef.current = void 0;
    previousFrameTimeRef.current = void 0;
    visibleTextAllLengthsRef.current = [];
    outputLengthsRef.current = [];
    visibleTextIncrementsRef.current = [];
    visibleTextLengthTargetRef.current = 0;
    frameCountRef.current = 0;
    if (frameRef.current) {
      cancelAnimationFrame(frameRef.current);
      frameRef.current = void 0;
    }
  }, [setState]);
  const restart = useCallback(() => {
    reset();
    setTimeout(() => {
      if (renderLoopRef.current) {
        frameRef.current = requestAnimationFrame(renderLoopRef.current);
      }
    }, 10);
  }, [reset]);
  const renderLoop = (frameTime) => {
    if (!renderLoopRef.current) {
      return;
    }
    const allMatches = matchBlocks({
      llmOutput,
      blocks,
      fallbackBlock,
      isStreamFinished
    });
    const visibleText = matchesToVisibleText(blockMatches);
    const outputRendered = matchesToOutput(blockMatches);
    const visibleTextAll = matchesToVisibleText(allMatches);
    const outputAll = matchesToOutput(allMatches);
    if (!isStreamFinished) {
      visibleTextAllLengthsRef.current.push(visibleTextAll.length);
      outputLengthsRef.current.push(outputAll.length);
    }
    const isFinished = visibleText === visibleTextAll && isStreamFinished;
    if (isFinished) {
      frameRef.current = void 0;
      setState((state2) => ({
        ...state2,
        blockMatches,
        isFinished,
        finishCount: state2.finishCount + 1,
        visibleText
      }));
      onFinish();
      return;
    }
    const visibleTextLengthsAll = isStreamFinished ? [...visibleTextAllLengthsRef.current, visibleTextAll.length] : visibleTextAllLengthsRef.current;
    const outputLengths = isStreamFinished ? [...outputLengthsRef.current, outputAll.length] : outputLengthsRef.current;
    const { visibleTextIncrement } = throttle({
      outputRaw: llmOutput,
      outputRendered,
      outputAll,
      visibleText,
      visibleTextAll,
      startStreamTime: startTime.current,
      isStreamFinished,
      frameCount: frameCountRef.current,
      frameTime,
      frameTimePrevious: previousFrameTimeRef.current,
      finishStreamTime: finishTimeRef.current,
      visibleTextLengthsAll,
      outputLengths,
      visibleTextIncrements: visibleTextIncrementsRef.current,
      visibleTextLengthTarget: visibleTextLengthTargetRef.current
    });
    if (visibleTextIncrement < 0) {
      throw new Error("throttle returned negative visibleTextIncrement");
    }
    visibleTextIncrementsRef.current.push(visibleTextIncrement);
    visibleTextLengthTargetRef.current = visibleTextLengthTargetRef.current + visibleTextIncrement;
    if (visibleTextLengthTargetRef.current > visibleText.length) {
      const matches = matchBlocks({
        llmOutput,
        blocks,
        fallbackBlock,
        isStreamFinished,
        visibleTextLengthTarget: visibleTextLengthTargetRef.current
      });
      const updatedVisibleText = matchesToVisibleText(matches);
      lastRenderTime.current = performance.now();
      setState((state2) => ({
        ...state2,
        blockMatches: matches,
        isFinished,
        visibleText: updatedVisibleText
      }));
    }
    frameRef.current = requestAnimationFrame(renderLoopRef.current);
    previousFrameTimeRef.current = frameTime;
    frameCountRef.current = frameCountRef.current + 1;
  };
  useEffect(() => {
    renderLoopRef.current = renderLoop;
  });
  useEffect(() => {
    renderLoopRef.current = renderLoop;
    if (!frameRef.current && llmOutput && llmOutput.length > 0) {
      frameRef.current = requestAnimationFrame(renderLoopRef.current);
    } else if (
      // reset the render loop if user clears the llmOutput
      visibleTextIncrementsRef.current.length > 0 && llmOutput.length === 0
    ) {
      reset();
    }
  }, [llmOutput]);
  useEffect(() => {
    () => {
      if (frameRef.current) {
        cancelAnimationFrame(frameRef.current);
      }
    };
  }, []);
  useEffect(() => {
    if (!finishTimeRef.current && isStreamFinished) {
      finishTimeRef.current = performance.now();
    }
  }, [isStreamFinished]);
  return { blockMatches, restart, ...state };
};

// src/examples/helper.ts
var cumulativeProbability = (probs) => {
  return probs.reduce((acc, curr) => {
    const previousProb = acc.length === 0 ? 0 : acc[acc.length - 1].prob;
    return [
      ...acc,
      {
        ...curr,
        prob: previousProb + curr.prob
      }
    ];
  }, []);
};
var stringToTokenArray = (llmOutput, { tokenCharsProbabilities, delayMsProbabilities }) => {
  const tokenCharsProbabilitiesCum = cumulativeProbability(
    tokenCharsProbabilities
  );
  const delayProbsCum = cumulativeProbability(delayMsProbabilities);
  let index = 0;
  const tokensWithDelay = [];
  while (index < llmOutput.length) {
    const tokenSizeRand = Math.random();
    const delayRand = Math.random();
    const remainingChars = llmOutput.length - index;
    const tokenSize = Math.min(
      tokenCharsProbabilitiesCum.find((tp) => tp.prob > tokenSizeRand)?.tokenChars ?? 1,
      remainingChars
    );
    const token = llmOutput.slice(index, index + tokenSize);
    const delay = delayProbsCum.find((dp) => dp.prob > delayRand)?.delayMs ?? 10;
    tokensWithDelay.push({ token, delayMs: delay });
    index += tokenSize;
  }
  return tokensWithDelay;
};

// src/examples/useStreamTokenArray.ts
import { useCallback as useCallback2, useEffect as useEffect2, useMemo as useMemo2, useRef as useRef2, useState as useState2 } from "react";
var useStreamTokenArrayOptionsDefaultOptions = {
  autoStartDelayMs: 0,
  autoStart: true,
  delayMultiplier: 1,
  startIndex: 0
};
var useStreamTokenArray = (tokenArray, userOptions) => {
  const nextTokenRef = useRef2();
  const options = useMemo2(
    () => ({
      ...useStreamTokenArrayOptionsDefaultOptions,
      ...userOptions ?? {}
    }),
    [userOptions]
  );
  const currentIndex = useRef2(
    Math.min(options.startIndex, tokenArray.length)
  );
  const [output, setOutput] = useState2(
    tokenArray.slice(0, currentIndex.current).map((t) => t.token).join("")
  );
  const [isPlaying, setIsPlaying] = useState2(options.autoStart);
  const clearTimeoutRef = useRef2(null);
  const pause = useCallback2(() => {
    if (clearTimeoutRef.current) {
      clearTimeout(clearTimeoutRef.current);
      clearTimeoutRef.current = null;
    }
    setIsPlaying(false);
  }, []);
  const reset = useCallback2(() => {
    setOutput("");
    pause();
    currentIndex.current = 0;
  }, []);
  const nextToken = useCallback2(async () => {
    if (!nextTokenRef.current) {
      return;
    }
    const index = currentIndex.current;
    const isFinished2 = index >= tokenArray.length;
    if (isFinished2) {
      setIsPlaying(false);
      clearTimeoutRef.current = null;
    } else {
      const { token, delayMs } = tokenArray[index];
      setOutput((prevOutput) => `${prevOutput}${token}`);
      currentIndex.current = index + 1;
      clearTimeoutRef.current = setTimeout(
        nextTokenRef.current,
        delayMs * options.delayMultiplier
      );
    }
  }, [options, setOutput, reset, tokenArray]);
  useEffect2(() => {
    nextTokenRef.current = nextToken;
  });
  const start = useCallback2(() => {
    if (clearTimeoutRef.current) {
      return;
    }
    setIsPlaying(true);
    nextToken();
  }, [tokenArray, currentIndex]);
  useEffect2(() => {
    if (options.autoStart) {
      setTimeout(start, options.autoStartDelayMs);
    }
  }, []);
  const finishedOutput = tokenArray.map((t) => t.token).join("");
  const isFinished = output.length === finishedOutput.length;
  return {
    output,
    reset,
    pause,
    start,
    isPlaying,
    isStreamStarted: output.length > 0,
    isStreamFinished: isFinished
  };
};

// src/examples/useStreamWithProbabilities.ts
import { useMemo as useMemo3, useRef as useRef3 } from "react";
var useStreamWithProbabilitiesDefaultOptions = {
  delayMsProbabilities: [
    { delayMs: 10, prob: 0.4 },
    { delayMs: 70, prob: 0.3 },
    { delayMs: 250, prob: 0.2 },
    { delayMs: 600, prob: 0.1 }
  ],
  tokenCharsProbabilities: [
    { tokenChars: 1, prob: 0.5 },
    { tokenChars: 2, prob: 0.3 },
    { tokenChars: 3, prob: 0.2 }
  ],
  ...useStreamTokenArrayOptionsDefaultOptions
};
var useStreamWithProbabilities = (output, userOptions) => {
  const options = useMemo3(
    () => ({
      ...useStreamWithProbabilitiesDefaultOptions,
      ...userOptions ?? {}
    }),
    [userOptions]
  );
  const tokenArrayRef = useRef3(
    stringToTokenArray(output, options)
  );
  return useStreamTokenArray(tokenArrayRef.current, options);
};
export {
  stringToTokenArray,
  throttleBasic,
  defaultOptions as throttleBasicDefaultOptions,
  useLLMOutput,
  useStreamWithProbabilities as useStreamExample,
  useStreamTokenArray,
  useStreamTokenArrayOptionsDefaultOptions,
  useStreamWithProbabilities,
  useStreamWithProbabilitiesDefaultOptions
};
//# sourceMappingURL=index.js.map