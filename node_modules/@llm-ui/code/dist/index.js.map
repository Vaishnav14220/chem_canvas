{"version":3,"sources":["../src/options.ts","../src/matchers.ts","../src/shared.ts","../src/parse.ts","../src/lookBack.ts","../src/hooks/useLoadHighlighter.ts","../src/hooks/useCodeToHtml.ts","../src/hooks/useCodeBlockToHtml.ts","../src/shikiBundles/allLangs.ts"],"sourcesContent":["export type CodeBlockOptions = {\n  startEndChars: string[];\n};\n\nexport const defaultOptions: CodeBlockOptions = {\n  startEndChars: [\"`\"],\n};\n\nexport const getOptions = (userOptions?: Partial<CodeBlockOptions>) => {\n  return { ...defaultOptions, ...userOptions };\n};\n","import { LLMOutputMatcher } from \"@llm-ui/react\";\nimport { CodeBlockOptions, getOptions } from \"./options\";\n\nimport { regexMatcher } from \"@llm-ui/shared\";\nimport { getStartEndGroup } from \"./shared\";\n\nexport const findCompleteCodeBlock = (\n  userOptions?: Partial<CodeBlockOptions>,\n): LLMOutputMatcher => {\n  const options = getOptions(userOptions);\n  const startEndGroup = getStartEndGroup(options.startEndChars);\n  const regex = new RegExp(\n    `${startEndGroup}.*\\n([\\\\s\\\\S]*?)\\n${startEndGroup}`,\n  );\n  return regexMatcher(regex);\n};\n\nexport const findPartialCodeBlock = (\n  userOptions?: Partial<CodeBlockOptions>,\n): LLMOutputMatcher => {\n  const options = getOptions(userOptions);\n  const regex = new RegExp(\n    `(${options.startEndChars.map((char) => `${char}{1,2}$|${char}{3}`).join(\"|\")})[\\\\s\\\\S]*`,\n  );\n  return regexMatcher(regex);\n};\n","export const getStartEndGroup = (startEndChars: string[]) => {\n  const triples = startEndChars.map((char) => char.repeat(3));\n  return `(${triples.join(\"|\")})`;\n};\n","import { CodeBlockOptions, getOptions } from \"./options\";\nimport { getStartEndGroup } from \"./shared\";\n\nexport type CodeBlock = {\n  language: string | undefined;\n  metaString: string | undefined;\n  code: string | undefined;\n};\n\nconst parseMarkdownCodeBlock = (\n  codeBlock: string,\n  startGroup: string,\n  endGroup: string,\n) => {\n  const lines = codeBlock.split(\"\\n\");\n  let language: string | undefined;\n  let metaString: string | undefined;\n  let code: string | undefined;\n  if (lines.length > 1) {\n    lines[0];\n    const regex = new RegExp(`${startGroup}([a-zA-Z0-9_-]*) *(.*)`);\n    const match = lines[0].match(regex);\n    if (match) {\n      language = match[2].length > 0 ? match[2] : undefined;\n      metaString = match[3].length > 0 ? match[3] : undefined;\n    }\n  }\n  // ?= is a lookahead to stop [\\\\s\\\\S]* from being too greedy\n  const regex = new RegExp(`${startGroup}.*\\n([\\\\s\\\\S]*?)(?=${endGroup})`);\n  const match = codeBlock.match(regex);\n  code = match ? match[2] : \"\";\n  return {\n    language,\n    metaString,\n    code,\n  };\n};\n\nexport type ParseFunction = (\n  codeBlock: string,\n  options?: CodeBlockOptions,\n) => CodeBlock;\n\nexport const parseCompleteMarkdownCodeBlock: ParseFunction = (\n  codeBlock,\n  userOptions,\n) => {\n  const options = getOptions(userOptions);\n  const startEndGroup = getStartEndGroup(options.startEndChars);\n  return parseMarkdownCodeBlock(codeBlock, startEndGroup, `\\n${startEndGroup}`);\n};\n\nexport const parsePartialMarkdownCodeBlock: ParseFunction = (\n  codeBlock,\n  userOptions,\n) => {\n  const options = getOptions(userOptions);\n  const startGroup = getStartEndGroup(options.startEndChars);\n  const endGroup = `(\\n${options.startEndChars\n    .map((char) => `${char}{0,2}$`)\n    .join(\"|\")}|$)`;\n  return parseMarkdownCodeBlock(codeBlock, startGroup, endGroup);\n};\n","import { LookBackFunction } from \"@llm-ui/react\";\nimport { CodeBlockOptions, getOptions } from \"./options\";\nimport {\n  parseCompleteMarkdownCodeBlock,\n  parsePartialMarkdownCodeBlock,\n} from \"./parse\";\n\nexport const codeBlockLookBack = (\n  userOptions?: Partial<CodeBlockOptions>,\n): LookBackFunction => {\n  const options = getOptions(userOptions);\n\n  return ({ output, isComplete, visibleTextLengthTarget }) => {\n    const parseFunction = isComplete\n      ? parseCompleteMarkdownCodeBlock\n      : parsePartialMarkdownCodeBlock;\n    const { code = \"\", language, metaString } = parseFunction(output, options);\n\n    const visibleCode = code.slice(0, visibleTextLengthTarget);\n    const startEndChar = options.startEndChars[0].repeat(3);\n    return {\n      output: `${startEndChar}${language ?? \"\"}${metaString ? ` ${metaString}` : \"\"}\\n${visibleCode}\\n${startEndChar}`,\n      visibleText: visibleCode,\n    };\n  };\n};\n","import { useEffect, useState } from \"react\";\nimport { HighlighterCore } from \"shiki/core\";\nimport { LLMUIHighlighter } from \"../types\";\n\n// Starts loading the highlighter immediately, hopefully it loads before it's needed\n// we can get the highlighter sync using getHighlighter and async using highlighterPromise\nexport const loadHighlighter = (\n  highlighter: Promise<HighlighterCore>,\n): LLMUIHighlighter => {\n  let highlighterInstance: HighlighterCore | undefined;\n  return {\n    getHighlighter: () => highlighterInstance,\n    highlighterPromise: highlighter.then((h) => {\n      highlighterInstance = h;\n      return h;\n    }),\n  };\n};\n\nexport const useLoadHighlighter = ({\n  getHighlighter,\n  highlighterPromise,\n}: LLMUIHighlighter) => {\n  const [highlighter, setHighlighter] = useState<HighlighterCore | undefined>(\n    getHighlighter(),\n  );\n\n  useEffect(() => {\n    if (!highlighter) {\n      if (getHighlighter()) {\n        setHighlighter(getHighlighter());\n      } else {\n        (async () => {\n          setHighlighter(await highlighterPromise);\n        })();\n      }\n    }\n  }, []);\n  return highlighter;\n};\n","import { ShikiProps } from \"../types\";\nimport { useLoadHighlighter } from \"./useLoadHighlighter\";\n\nexport type UseCodeToHtmlParams = {\n  code: string;\n} & ShikiProps;\n\nexport const useCodeToHtml = ({\n  code,\n  highlighter,\n  codeToHtmlOptions,\n}: UseCodeToHtmlParams): string => {\n  const shikiHighlighter = useLoadHighlighter(highlighter);\n  if (!shikiHighlighter) {\n    return \"\";\n  }\n  return shikiHighlighter.codeToHtml(code, {\n    ...codeToHtmlOptions,\n    lang: codeToHtmlOptions.lang ?? \"plain\",\n  });\n};\n","import { ParseFunction, parseCompleteMarkdownCodeBlock } from \"../parse\";\nimport { ShikiProps } from \"../types\";\nimport { useCodeToHtml } from \"./useCodeToHtml\";\n\nexport type UseCodeBlockToHtmlParams = {\n  markdownCodeBlock: string;\n  parser?: ParseFunction;\n} & ShikiProps;\n\nexport type UseCodeBlockToHtmlReturn = {\n  html: string | undefined;\n  code: string;\n};\n\nexport const useCodeBlockToHtml = ({\n  markdownCodeBlock,\n  highlighter,\n  codeToHtmlOptions,\n  parser = parseCompleteMarkdownCodeBlock,\n}: UseCodeBlockToHtmlParams) => {\n  const { code = \"\\n\", language } = parser(markdownCodeBlock);\n  const lang = codeToHtmlOptions.lang ?? language ?? \"plain\";\n  const html = useCodeToHtml({\n    code,\n    highlighter,\n    codeToHtmlOptions: { ...codeToHtmlOptions, lang },\n  });\n  return { html, code };\n};\n","import { BundledLanguageInfo, LanguageRegistration } from \"shiki/core\";\n\nexport const allLangs = (\n  bundledLanguagesInfo: BundledLanguageInfo[],\n): Promise<{\n  default: LanguageRegistration[];\n}>[] => bundledLanguagesInfo.map((lang) => lang.import());\n\ntype LangAlias = Record<string, string>;\n\nexport const allLangsAlias = (\n  bundledLanguagesInfo: BundledLanguageInfo[],\n): LangAlias =>\n  bundledLanguagesInfo.reduce((acc, lang) => {\n    if (lang.aliases) {\n      for (const alias of lang.aliases) {\n        acc[alias] = lang.id;\n      }\n    }\n    return acc;\n  }, {} as LangAlias);\n"],"mappings":"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","names":["regex","match"]}