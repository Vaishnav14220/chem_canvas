// src/options.ts
var defaultOptions = {
  startEndChars: ["`"]
};
var getOptions = (userOptions) => {
  return { ...defaultOptions, ...userOptions };
};

// src/matchers.ts
import { regexMatcher } from "@llm-ui/shared";

// src/shared.ts
var getStartEndGroup = (startEndChars) => {
  const triples = startEndChars.map((char) => char.repeat(3));
  return `(${triples.join("|")})`;
};

// src/matchers.ts
var findCompleteCodeBlock = (userOptions) => {
  const options = getOptions(userOptions);
  const startEndGroup = getStartEndGroup(options.startEndChars);
  const regex = new RegExp(
    `${startEndGroup}.*
([\\s\\S]*?)
${startEndGroup}`
  );
  return regexMatcher(regex);
};
var findPartialCodeBlock = (userOptions) => {
  const options = getOptions(userOptions);
  const regex = new RegExp(
    `(${options.startEndChars.map((char) => `${char}{1,2}$|${char}{3}`).join("|")})[\\s\\S]*`
  );
  return regexMatcher(regex);
};

// src/parse.ts
var parseMarkdownCodeBlock = (codeBlock, startGroup, endGroup) => {
  const lines = codeBlock.split("\n");
  let language;
  let metaString;
  let code;
  if (lines.length > 1) {
    lines[0];
    const regex2 = new RegExp(`${startGroup}([a-zA-Z0-9_-]*) *(.*)`);
    const match2 = lines[0].match(regex2);
    if (match2) {
      language = match2[2].length > 0 ? match2[2] : void 0;
      metaString = match2[3].length > 0 ? match2[3] : void 0;
    }
  }
  const regex = new RegExp(`${startGroup}.*
([\\s\\S]*?)(?=${endGroup})`);
  const match = codeBlock.match(regex);
  code = match ? match[2] : "";
  return {
    language,
    metaString,
    code
  };
};
var parseCompleteMarkdownCodeBlock = (codeBlock, userOptions) => {
  const options = getOptions(userOptions);
  const startEndGroup = getStartEndGroup(options.startEndChars);
  return parseMarkdownCodeBlock(codeBlock, startEndGroup, `
${startEndGroup}`);
};
var parsePartialMarkdownCodeBlock = (codeBlock, userOptions) => {
  const options = getOptions(userOptions);
  const startGroup = getStartEndGroup(options.startEndChars);
  const endGroup = `(
${options.startEndChars.map((char) => `${char}{0,2}$`).join("|")}|$)`;
  return parseMarkdownCodeBlock(codeBlock, startGroup, endGroup);
};

// src/lookBack.ts
var codeBlockLookBack = (userOptions) => {
  const options = getOptions(userOptions);
  return ({ output, isComplete, visibleTextLengthTarget }) => {
    const parseFunction = isComplete ? parseCompleteMarkdownCodeBlock : parsePartialMarkdownCodeBlock;
    const { code = "", language, metaString } = parseFunction(output, options);
    const visibleCode = code.slice(0, visibleTextLengthTarget);
    const startEndChar = options.startEndChars[0].repeat(3);
    return {
      output: `${startEndChar}${language ?? ""}${metaString ? ` ${metaString}` : ""}
${visibleCode}
${startEndChar}`,
      visibleText: visibleCode
    };
  };
};

// src/hooks/useLoadHighlighter.ts
import { useEffect, useState } from "react";
var loadHighlighter = (highlighter) => {
  let highlighterInstance;
  return {
    getHighlighter: () => highlighterInstance,
    highlighterPromise: highlighter.then((h) => {
      highlighterInstance = h;
      return h;
    })
  };
};
var useLoadHighlighter = ({
  getHighlighter,
  highlighterPromise
}) => {
  const [highlighter, setHighlighter] = useState(
    getHighlighter()
  );
  useEffect(() => {
    if (!highlighter) {
      if (getHighlighter()) {
        setHighlighter(getHighlighter());
      } else {
        (async () => {
          setHighlighter(await highlighterPromise);
        })();
      }
    }
  }, []);
  return highlighter;
};

// src/hooks/useCodeToHtml.ts
var useCodeToHtml = ({
  code,
  highlighter,
  codeToHtmlOptions
}) => {
  const shikiHighlighter = useLoadHighlighter(highlighter);
  if (!shikiHighlighter) {
    return "";
  }
  return shikiHighlighter.codeToHtml(code, {
    ...codeToHtmlOptions,
    lang: codeToHtmlOptions.lang ?? "plain"
  });
};

// src/hooks/useCodeBlockToHtml.ts
var useCodeBlockToHtml = ({
  markdownCodeBlock,
  highlighter,
  codeToHtmlOptions,
  parser = parseCompleteMarkdownCodeBlock
}) => {
  const { code = "\n", language } = parser(markdownCodeBlock);
  const lang = codeToHtmlOptions.lang ?? language ?? "plain";
  const html = useCodeToHtml({
    code,
    highlighter,
    codeToHtmlOptions: { ...codeToHtmlOptions, lang }
  });
  return { html, code };
};

// src/shikiBundles/allLangs.ts
var allLangs = (bundledLanguagesInfo) => bundledLanguagesInfo.map((lang) => lang.import());
var allLangsAlias = (bundledLanguagesInfo) => bundledLanguagesInfo.reduce((acc, lang) => {
  if (lang.aliases) {
    for (const alias of lang.aliases) {
      acc[alias] = lang.id;
    }
  }
  return acc;
}, {});
export {
  allLangs,
  allLangsAlias,
  codeBlockLookBack,
  defaultOptions as defaultCodeBlockOptions,
  findCompleteCodeBlock,
  findPartialCodeBlock,
  loadHighlighter,
  parseCompleteMarkdownCodeBlock,
  parsePartialMarkdownCodeBlock,
  useCodeBlockToHtml,
  useCodeToHtml
};
//# sourceMappingURL=index.js.map