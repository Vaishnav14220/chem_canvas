import type { MoleculeData } from './pubchemService';

const RCSB_SEARCH_URL = 'https://search.rcsb.org/rcsbsearch/v2/query';
const RCSB_ENTRY_URL = 'https://data.rcsb.org/rest/v1/core/entry';
const RCSB_PDB_DOWNLOAD_URL = 'https://files.rcsb.org/download';
const ALPHAFOLD_ENTRY_URL = 'https://alphafold.ebi.ac.uk/api/prediction';
const CORS_PROXY_PREFIX = 'https://corsproxy.io/?';

export interface ProteinSearchResult {
  pdbId: string;
  title: string;
  polymerType?: string;
  organism?: string;
  released?: string;
  resolution?: number;
  source: 'rcsb' | 'alphafold';
  pdbUrl?: string;
  cifUrl?: string;
  bcifUrl?: string;
  paeImageUrl?: string;
  paeDocUrl?: string;
  modelCreatedDate?: string;
  sequenceLength?: number;
  uniprotAccession?: string;
  confidence?: number;
}

interface ProteinAtom {
  element: string;
  x: number;
  y: number;
  z: number;
  atomName: string;
}

const ATOMIC_WEIGHTS: Record<string, number> = {
  H: 1.008,
  He: 4.0026,
  Li: 6.94,
  Be: 9.0122,
  B: 10.81,
  C: 12.011,
  N: 14.007,
  O: 15.999,
  F: 18.998,
  Na: 22.99,
  Mg: 24.305,
  Al: 26.982,
  Si: 28.085,
  P: 30.974,
  S: 32.06,
  Cl: 35.45,
  K: 39.098,
  Ca: 40.078,
  Cr: 51.996,
  Mn: 54.938,
  Fe: 55.845,
  Co: 58.933,
  Ni: 58.693,
  Cu: 63.546,
  Zn: 65.38,
  Se: 78.971,
};

const COVALENT_RADII: Record<string, number> = {
  H: 0.31,
  C: 0.76,
  N: 0.71,
  O: 0.66,
  F: 0.57,
  P: 1.07,
  S: 1.05,
  Cl: 1.02,
  Se: 1.2,
  Na: 1.66,
  Mg: 1.41,
  K: 2.03,
  Ca: 1.76,
  Fe: 1.24,
  Cu: 1.32,
  Zn: 1.22,
};

const fetchWithRetry = async (
  url: string,
  options: RequestInit | undefined = undefined,
  retries = 3
): Promise<Response | null> => {
  for (let attempt = 0; attempt < retries; attempt++) {
    try {
      const response = await fetch(url, options);
      if (response.ok) {
        return response;
      }

      if (response.status === 429 && attempt < retries - 1) {
        await new Promise((resolve) => setTimeout(resolve, 1000 * (attempt + 1)));
        continue;
      }

      if (attempt === retries - 1) {
        return response;
      }
    } catch (error) {
      if (attempt === retries - 1) {
        throw error;
      }
      await new Promise((resolve) => setTimeout(resolve, 500 * (attempt + 1)));
    }
  }

  return null;
};

const fetchWithProxy = async (
  url: string,
  options?: RequestInit
): Promise<Response | null> => {
  const response = await fetchWithRetry(url, options);
  if (response && response.ok) {
    return response;
  }
  const proxiedUrl = `${CORS_PROXY_PREFIX}${encodeURIComponent(url)}`;
  return fetchWithRetry(proxiedUrl, options);
};

const computeMolecularWeight = (atoms: ProteinAtom[]) =>
  atoms.reduce((total, atom) => {
    const weight = ATOMIC_WEIGHTS[atom.element] ?? 0;
    return total + weight;
  }, 0);

const buildSDF = (
  atoms: ProteinAtom[],
  bonds: Array<{ from: number; to: number; order: number }>,
  title: string
) => {
  const header = [
    title.substring(0, 80),
    ' Generated by proteinService',
    '',
  ].join('\n');

  const countsLine = `${atoms.length.toString().padStart(3, ' ')}${bonds.length
    .toString()
    .padStart(3, ' ')}  0  0  0  0            999 V2000`;

  const atomLines = atoms
    .map(atom => {
      const x = atom.x.toFixed(4).padStart(10, ' ');
      const y = atom.y.toFixed(4).padStart(10, ' ');
      const z = atom.z.toFixed(4).padStart(10, ' ');
      const element = atom.element.padStart(3, ' ');
      return `${x}${y}${z} ${element} 0  0  0  0  0  0  0  0  0  0  0  0`;
    })
    .join('\n');

  const bondLines = bonds
    .map(bond => {
      const from = (bond.from + 1).toString().padStart(3, ' ');
      const to = (bond.to + 1).toString().padStart(3, ' ');
      const order = bond.order.toString().padStart(3, ' ');
      return `${from}${to}${order}  0  0  0  0`;
    })
    .join('\n');

  return `${header}\n${countsLine}\n${atomLines}${bondLines ? `\n${bondLines}` : ''}\nM  END`;
};

const groupAtoms = (atoms: ProteinAtom[], cellSize = 2.0) => {
  const cells = new Map<string, number[]>();

  const keyOf = (atom: ProteinAtom) => {
    const xi = Math.floor(atom.x / cellSize);
    const yi = Math.floor(atom.y / cellSize);
    const zi = Math.floor(atom.z / cellSize);
    return `${xi},${yi},${zi}`;
  };

  atoms.forEach((atom, index) => {
    const key = keyOf(atom);
    const bucket = cells.get(key);
    if (bucket) {
      bucket.push(index);
    } else {
      cells.set(key, [index]);
    }
  });

  return { cells, cellSize };
};

const inferBonds = (atoms: ProteinAtom[]) => {
  const { cells, cellSize } = groupAtoms(atoms);
  const bonds: Array<{ from: number; to: number; order: number }> = [];

  const neighboringOffsets = [-1, 0, 1];
  const getCellCoords = (atom: ProteinAtom) => ({
    x: Math.floor(atom.x / cellSize),
    y: Math.floor(atom.y / cellSize),
    z: Math.floor(atom.z / cellSize),
  });

  atoms.forEach((atom, index) => {
    const { x, y, z } = getCellCoords(atom);
    neighboringOffsets.forEach(dx => {
      neighboringOffsets.forEach(dy => {
        neighboringOffsets.forEach(dz => {
          const key = `${x + dx},${y + dy},${z + dz}`;
          const bucket = cells.get(key);
          if (!bucket) return;

          bucket.forEach(neighborIndex => {
            if (neighborIndex <= index) return;
            const neighbor = atoms[neighborIndex];
            const dxCoord = atom.x - neighbor.x;
            const dyCoord = atom.y - neighbor.y;
            const dzCoord = atom.z - neighbor.z;
            const distance = Math.sqrt(dxCoord ** 2 + dyCoord ** 2 + dzCoord ** 2);
            const radiusSum =
              (COVALENT_RADII[atom.element] ?? 1.7) +
              (COVALENT_RADII[neighbor.element] ?? 1.7) +
              0.45;
            if (distance <= radiusSum) {
              bonds.push({ from: index, to: neighborIndex, order: 1 });
            }
          });
        });
      });
    });
  });

  return bonds;
};

const parsePDB = (pdbText: string): ProteinAtom[] => {
  const lines = pdbText.split(/\r?\n/);
  const atoms: ProteinAtom[] = [];

  for (const line of lines) {
    if (!(line.startsWith('ATOM') || line.startsWith('HETATM'))) {
      continue;
    }

    const x = Number.parseFloat(line.slice(30, 38));
    const y = Number.parseFloat(line.slice(38, 46));
    const z = Number.parseFloat(line.slice(46, 54));
    const atomName = line.slice(12, 16).trim();
    let element = line.length >= 78 ? line.slice(76, 78).trim() : '';
    if (!element) {
      element = atomName.replace(/[0-9]/g, '');
    }
    element = element.charAt(0).toUpperCase() + element.slice(1).toLowerCase();
    if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z) || !element) {
      continue;
    }

    atoms.push({ element, x, y, z, atomName });
  }

  return atoms;
};

const computeFormula = (atoms: ProteinAtom[]) => {
  const counts = new Map<string, number>();
  atoms.forEach(atom => {
    counts.set(atom.element, (counts.get(atom.element) ?? 0) + 1);
  });
  const sortedElements = Array.from(counts.keys()).sort();
  return sortedElements.map(element => `${element}${counts.get(element) ?? ''}`).join(' ');
};

const formatResolution = (value?: number) => {
  if (!value || Number.isNaN(value)) return undefined;
  return Number.parseFloat(value.toString()).toFixed(2);
};

const fetchAlphaFoldPredictions = async (
  term: string,
  limit: number
): Promise<ProteinSearchResult[]> => {
  const uniProtUrl = `https://rest.uniprot.org/uniprotkb/search?query=${encodeURIComponent(term)}&format=json&size=${limit}`;

  try {
    const response = await fetchWithProxy(uniProtUrl);
    if (!response || !response.ok) {
      return [];
    }

    const payload = await response.json();
    const entries: any[] = Array.isArray(payload?.results) ? payload.results : [];

    const results: ProteinSearchResult[] = [];
    for (const entry of entries) {
      const accession: string | undefined = entry?.primaryAccession;
      if (!accession) continue;

      try {
        const predictionResponse = await fetchWithProxy(`${ALPHAFOLD_ENTRY_URL}/${accession}`);
        if (!predictionResponse || !predictionResponse.ok) {
          continue;
        }
        const predictions: any[] = await predictionResponse.json();
        const model = Array.isArray(predictions) ? predictions[0] : null;
        if (!model || !model?.pdbUrl) {
          continue;
        }

        const title =
          entry?.proteinDescription?.recommendedName?.fullName?.value ??
          entry?.proteinDescription?.submissionNames?.[0]?.fullName?.value ??
          entry?.uniProtkbId ??
          accession;

        const organism =
          entry?.organism?.scientificName ??
          entry?.organism?.commonName ??
          model?.organismScientificName;

        results.push({
          pdbId: accession.toUpperCase(),
          title,
          organism,
          polymerType: 'Protein (Predicted)',
          released: model?.modelCreatedDate,
          resolution: undefined,
          source: 'alphafold',
          pdbUrl: model.pdbUrl,
          cifUrl: model.cifUrl,
          bcifUrl: model.bcifUrl,
          paeImageUrl: model.paeImageUrl,
          paeDocUrl: model.paeDocUrl,
          modelCreatedDate: model.modelCreatedDate,
          sequenceLength: model.uniprotEnd ?? model.uniprotSequence?.length ?? undefined,
          uniprotAccession: accession,
          confidence: Number.isFinite(model?.globalMetricValue)
            ? Number(model.globalMetricValue)
            : undefined,
        });
      } catch (error) {
        console.warn(`AlphaFold lookup failed for ${accession}:`, error);
      }
    }

    return results.slice(0, limit);
  } catch (error) {
    console.warn('AlphaFold/UniProt search failed:', error);
    return [];
  }
};

export const searchProteins = async (
  query: string,
  maxResults = 12
): Promise<ProteinSearchResult[]> => {
  const trimmed = query.trim();
  if (!trimmed) {
    return [];
  }

  const searchTerms = new Set<string>([trimmed]);

  try {
    const autoUrl = `https://pubchem.ncbi.nlm.nih.gov/pcautocp/pcautocp.cgi?dict=pc_compoundnames&n=10&q=${encodeURIComponent(
      trimmed
    )}`;
    const autoResponse = await fetchWithProxy(autoUrl);
    if (autoResponse && autoResponse.ok) {
      const autoJson = await autoResponse.json();
      const suggestions: string[] = Array.isArray(autoJson?.autocp_array)
        ? autoJson.autocp_array.slice(0, 8)
        : [];
      suggestions.forEach((suggestion) => {
        const cleaned = suggestion?.trim();
        if (cleaned) {
          searchTerms.add(cleaned);
        }
      });
    }
  } catch (error) {
    console.warn('PubChem autocomplete failed, continuing with base term:', error);
  }

  try {
    const candidateIds = new Set<string>();
    const addIdsFromSearch = (resultSet: Array<{ identifier: string }>) => {
      resultSet.forEach(result => {
        if (result?.identifier) {
          candidateIds.add(result.identifier.toUpperCase());
        }
      });
    };

    const buildQueryConfigs = (term: string) => [
      {
        type: 'terminal',
        service: 'text',
        parameters: {
          target: 'full_text',
          value: term,
        },
      },
      {
        type: 'terminal',
        service: 'text',
        parameters: {
          attribute: 'struct.title',
          operator: 'contains_phrase',
          value: term,
        },
      },
      {
        type: 'terminal',
        service: 'text',
        parameters: {
          attribute: 'rcsb_polymer_entity_container_identifiers.preferred_name',
          operator: 'contains_phrase',
          value: term,
        },
      },
      {
        type: 'terminal',
        service: 'text',
        parameters: {
          attribute: 'rcsb_polymer_entity.rcsb_macromolecule_name',
          operator: 'contains_phrase',
          value: term,
        },
      },
    ];

    const runQuery = async (queryConfig: Record<string, unknown>, termLabel: string) => {
      const body = {
        query: queryConfig,
        return_type: 'entry',
        request_options: {
          pager: {
            start: 0,
            rows: maxResults,
          },
          results_content_type: ['experimental'],
        },
      };

      try {
        const response = await fetchWithProxy(RCSB_SEARCH_URL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Accept: 'application/json',
          },
          body: JSON.stringify(body),
        });

        if (!response || !response.ok) {
          return;
        }

        const payload = await response.json();
        const resultSet: Array<{ identifier: string }> = Array.isArray(payload?.result_set)
          ? payload.result_set
          : [];
        addIdsFromSearch(resultSet);
      } catch (error) {
        console.warn(`Protein search query failed (${termLabel})`, error);
      }
    };

    for (const term of Array.from(searchTerms)) {
      const configs = buildQueryConfigs(term);
      for (const config of configs) {
        await runQuery(config, term);
        if (candidateIds.size >= maxResults) {
          break;
        }
      }
      if (candidateIds.size >= maxResults) {
        break;
      }
    }

    const pdbIdLike = /^[0-9A-Za-z]{4}$/;
    if (pdbIdLike.test(trimmed)) {
      candidateIds.add(trimmed.toUpperCase());
    }

    const uniqueIds = Array.from(candidateIds).slice(0, maxResults);

    const entries = await Promise.all(
      uniqueIds.map(async (pdbId) => {
        try {
          const entryResponse = await fetchWithProxy(`${RCSB_ENTRY_URL}/${pdbId}`);
          if (!entryResponse || !entryResponse.ok) {
            return null;
          }
          const entryData = await entryResponse.json();
          const title: string =
            entryData?.struct?.title ||
            entryData?.struct?.pdbx_descriptor ||
            `PDB ${pdbId}`;
          const organism =
            entryData?.rcsb_entity_src_nat?.[0]?.organism_common_name ||
            entryData?.rcsb_entity_src_nat?.[0]?.organism_scientific_name;
          const resolution = formatResolution(entryData?.rcsb_entry_info?.resolution_combined?.[0]);
          const polymerType = entryData?.rcsb_entry_info?.polymer_classification;
          const released = entryData?.rcsb_accession_info?.initial_release_date;

          return {
            pdbId,
            title,
            organism,
            polymerType,
            released,
            resolution: resolution ? Number.parseFloat(resolution) : undefined,
            source: 'rcsb' as const,
          } as ProteinSearchResult;
        } catch (err) {
          console.warn(`Failed to fetch metadata for ${pdbId}:`, err);
          return null;
        }
      })
    );

    const rcsbResults = entries.filter((entry): entry is ProteinSearchResult => Boolean(entry));

    const alphafoldResultsArrays = await Promise.all(
      Array.from(searchTerms).map((term) => fetchAlphaFoldPredictions(term, maxResults))
    );
    const alphafoldResults = alphafoldResultsArrays.flat();

    const seenIds = new Set<string>();
    const combined: ProteinSearchResult[] = [];

    [...rcsbResults, ...alphafoldResults].forEach(result => {
      if (!result?.pdbId) return;
      const key = `${result.source}:${result.pdbId}`;
      if (seenIds.has(key)) return;
      seenIds.add(key);
      combined.push(result);
    });

    return combined.slice(0, maxResults);
  } catch (err) {
    console.error('Protein search error:', err);
    return [];
  }
};

export const getAlphaFoldProteinStructure = async (
  accession: string,
  meta?: {
    title?: string;
    organism?: string;
    pdbUrl?: string;
    cifUrl?: string;
    bcifUrl?: string;
    paeImageUrl?: string;
    paeDocUrl?: string;
    confidence?: number;
    modelCreatedDate?: string;
    sequenceLength?: number;
  }
): Promise<MoleculeData | null> => {
  const trimmed = accession.trim().toUpperCase();
  if (!trimmed) {
    return null;
  }

  let metadata = meta;

  if (!metadata || !metadata.pdbUrl) {
    try {
      const metaResponse = await fetchWithProxy(`${ALPHAFOLD_ENTRY_URL}/${trimmed}`);
      if (metaResponse && metaResponse.ok) {
        const predictions: any[] = await metaResponse.json();
        const model = Array.isArray(predictions) ? predictions[0] : null;
        if (model) {
          metadata = {
            title: metadata?.title ?? model.uniprotDescription,
            organism: metadata?.organism ?? model.organismScientificName,
            pdbUrl: model.pdbUrl,
            cifUrl: model.cifUrl,
            bcifUrl: model.bcifUrl,
            paeImageUrl: model.paeImageUrl,
            paeDocUrl: model.paeDocUrl,
            confidence: metadata?.confidence ?? (Number.isFinite(model.globalMetricValue) ? Number(model.globalMetricValue) : undefined),
            modelCreatedDate: model.modelCreatedDate,
            sequenceLength: metadata?.sequenceLength ?? model.uniprotEnd ?? model.uniprotSequence?.length ?? undefined,
          };
        }
      }
    } catch (error) {
      console.warn('AlphaFold metadata fetch failed:', error);
    }
  }

  const resolvedUrl =
    metadata?.pdbUrl ?? `https://alphafold.ebi.ac.uk/files/AF-${trimmed}-F1-model_v4.pdb`;

  try {
    const response = await fetchWithProxy(resolvedUrl);
    if (!response || !response.ok) {
      console.warn('AlphaFold PDB fetch failed for', trimmed, response?.status);
      return null;
    }

    const pdbText = await response.text();
    const atoms = parsePDB(pdbText);
    if (atoms.length === 0) {
      console.warn('AlphaFold PDB parse yielded zero atoms for', trimmed);
      return null;
    }

    const bonds = inferBonds(atoms);
    const sdf = buildSDF(atoms, bonds, trimmed);
    const formula = computeFormula(atoms);
    const molecularWeight = computeMolecularWeight(atoms);

    return {
      name: metadata?.title || trimmed,
      displayName: `${metadata?.title || trimmed} (AlphaFold)`,
      cid: Number.isFinite(Number.parseInt(trimmed, 36))
        ? Number.parseInt(trimmed, 36)
        : Date.now(),
      molecularFormula: formula || 'Protein',
      molecularWeight,
      svgUrl: '',
      svgData: undefined,
      smiles: '',
      sdfData: sdf,
      sdf3DData: sdf,
      source: 'alphafold',
      role: 'protein',
      sourceQuery: trimmed,
      pdbId: trimmed,
      pdbUrl: resolvedUrl,
      organism: metadata?.organism,
      alphaFold: {
        uniprotId: trimmed,
        title: metadata?.title || trimmed,
        organism: metadata?.organism,
        pdbUrl: resolvedUrl,
        cifUrl: metadata?.cifUrl,
        bcifUrl: metadata?.bcifUrl,
        paeImageUrl: metadata?.paeImageUrl,
        paeDocUrl: metadata?.paeDocUrl,
        confidence: metadata?.confidence,
        modelCreatedDate: metadata?.modelCreatedDate,
        sequenceLength: metadata?.sequenceLength,
      },
    };
  } catch (error) {
    console.error('AlphaFold structure conversion failed:', error);
    return null;
  }
};

export const getProteinStructure = async (pdbId: string): Promise<MoleculeData | null> => {
  const trimmed = pdbId.trim().toUpperCase();
  if (!trimmed) {
    return null;
  }

  let pdbText: string | null = null;

  try {
    const downloadUrl = `${RCSB_PDB_DOWNLOAD_URL}/${encodeURIComponent(trimmed)}.pdb`;
    const response = await fetchWithProxy(downloadUrl);
    if (response && response.ok) {
      pdbText = await response.text();
    }
  } catch (err) {
    console.warn(`Primary PDB download failed for ${trimmed}`, err);
  }

  if (!pdbText) {
    console.warn('Unable to retrieve PDB file for', trimmed);
    return null;
  }

  const atoms = parsePDB(pdbText);
  if (atoms.length === 0) {
    console.warn('Parsed 0 atoms from PDB', trimmed);
    return null;
  }

  const bonds = inferBonds(atoms);
  const sdf = buildSDF(atoms, bonds, trimmed);
  const formula = computeFormula(atoms);
  const molecularWeight = computeMolecularWeight(atoms);

  return {
    name: trimmed,
    displayName: `${trimmed} Protein`,
    cid: Number.parseInt(trimmed, 36),
    molecularFormula: formula || 'Protein',
    molecularWeight,
    svgUrl: '',
    svgData: undefined,
    smiles: '',
    sdfData: sdf,
    sdf3DData: sdf,
    source: 'rcsb',
    role: 'protein',
    sourceQuery: trimmed,
    pdbId: trimmed,
  };
};





