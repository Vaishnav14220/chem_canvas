/**
 * LaTeX Document Agent Service
 * 
 * A Deep Agent implementation specialized for creating complete LaTeX documents.
 * Implements the deepagents concepts:
 * - Planning & Task Decomposition (write_todos)
 * - Context Management (in-memory file system)
 * - Subagent Spawning (specialized document agents)
 * - SwiftLaTeX integration for compilation
 * 
 * Based on: https://www.npmjs.com/package/deepagents
 */

import { GoogleGenAI } from '@google/genai';
import { getSharedGeminiApiKey } from '../firebase/apiKeys';
import { isGeminiInitialized, initializeGeminiWithFirebaseKey } from './geminiService';

// ==========================================
// Type Definitions
// ==========================================

export interface LaTeXTodoItem {
  id: string;
  title: string;
  status: 'pending' | 'in-progress' | 'completed';
  description?: string;
  priority?: 'high' | 'medium' | 'low';
}

export interface LaTeXFile {
  name: string;
  path: string;
  content: string;
  type: 'tex' | 'bib' | 'cls' | 'sty' | 'image' | 'other';
  lastModified: Date;
}

export interface CompileResult {
  success: boolean;
  pdfData?: Uint8Array;
  pdfUrl?: string;
  log: string;
  errors: string[];
  warnings: string[];
}

export interface LaTeXAgentMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: Date;
  todos?: LaTeXTodoItem[];
  filesModified?: string[];
  subagentUsed?: string;
  toolsUsed?: string[];
  compileResult?: CompileResult;
}

export interface SubAgent {
  name: string;
  description: string;
  systemPrompt: string;
  tools: string[];
}

export interface LaTeXProject {
  name: string;
  mainFile: string;
  files: Map<string, LaTeXFile>;
  todos: LaTeXTodoItem[];
  compileHistory: CompileResult[];
}

// ==========================================
// In-Memory File System (Context Management)
// ==========================================

class LaTeXFileSystem {
  private files: Map<string, LaTeXFile> = new Map();
  private projectName: string = 'untitled';

  constructor() {
    // Initialize with a basic main.tex template
    this.initializeDefaultProject();
  }

  private initializeDefaultProject(): void {
    const mainTex: LaTeXFile = {
      name: 'main.tex',
      path: '/main.tex',
      content: `%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Research Paper Template
% Generated by LaTeX Document Agent
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\\documentclass[12pt,a4paper]{article}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PACKAGES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Encoding and fonts
\\usepackage[utf8]{inputenc}
\\usepackage[T1]{fontenc}
\\usepackage{lmodern}           % Modern font family

% Mathematics
\\usepackage{amsmath,amssymb,amsthm}
\\usepackage{mathtools}         % Enhanced math features

% Graphics and figures
\\usepackage{graphicx}
\\usepackage{float}             % Better figure placement
\\usepackage{caption}           % Custom captions
\\usepackage{subcaption}        % Subfigures

% Tables
\\usepackage{booktabs}          % Professional tables
\\usepackage{tabularx}          % Flexible column widths
\\usepackage{multirow}          % Multi-row cells

% Layout and formatting
\\usepackage{geometry}
\\usepackage{setspace}          % Line spacing
\\usepackage{parskip}           % Paragraph spacing
\\usepackage{fancyhdr}          % Headers and footers
\\usepackage{enumitem}          % Custom lists

% Colors and links
\\usepackage{xcolor}
\\usepackage{hyperref}

% Bibliography
\\usepackage[numbers,sort&compress]{natbib}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PAGE LAYOUT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\\geometry{
    top=1in,
    bottom=1in,
    left=1in,
    right=1in
}

\\setstretch{1.5}               % 1.5 line spacing

% Header/Footer configuration
\\pagestyle{fancy}
\\fancyhf{}
\\fancyhead[L]{\\nouppercase{\\leftmark}}
\\fancyhead[R]{\\thepage}
\\renewcommand{\\headrulewidth}{0.4pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CUSTOM COMMANDS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\\newcommand{\\R}{\\mathbb{R}}
\\newcommand{\\N}{\\mathbb{N}}
\\newcommand{\\Z}{\\mathbb{Z}}
\\newcommand{\\ie}{\\textit{i.e.}}
\\newcommand{\\eg}{\\textit{e.g.}}
\\newcommand{\\etc}{\\textit{etc.}}

% Theorem environments
\\newtheorem{theorem}{Theorem}[section]
\\newtheorem{lemma}[theorem]{Lemma}
\\newtheorem{corollary}[theorem]{Corollary}
\\newtheorem{proposition}[theorem]{Proposition}
\\theoremstyle{definition}
\\newtheorem{definition}[theorem]{Definition}
\\newtheorem{example}[theorem]{Example}
\\theoremstyle{remark}
\\newtheorem{remark}[theorem]{Remark}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HYPERREF SETUP
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\\hypersetup{
    colorlinks=true,
    linkcolor=blue!70!black,
    citecolor=green!50!black,
    urlcolor=blue!80!black,
    pdfauthor={Author Name},
    pdftitle={Research Paper Title},
    pdfsubject={Subject Area},
    pdfkeywords={keyword1, keyword2, keyword3}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DOCUMENT INFORMATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\\title{\\textbf{Research Paper Title}\\\\[0.5em]
\\large Subtitle or Additional Information}

\\author{
    First Author\\textsuperscript{1,*}\\and
    Second Author\\textsuperscript{2}\\and
    Third Author\\textsuperscript{1,2}\\\\[1em]
    \\textsuperscript{1}Department of Chemistry, University Name, City, Country\\\\
    \\textsuperscript{2}Institute of Research, Organization Name, City, Country\\\\[0.5em]
    \\textsuperscript{*}Corresponding author: email@university.edu
}

\\date{\\today}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DOCUMENT BEGINS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\\begin{document}

% Title page
\\maketitle
\\thispagestyle{empty}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ABSTRACT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\\begin{abstract}
\\noindent
This is a placeholder for your abstract. The abstract should provide a concise summary of the research, including the background, objectives, methods, key results, and conclusions. It should be self-contained and typically 150-300 words in length. The abstract helps readers quickly determine if the paper is relevant to their interests.

\\vspace{1em}
\\noindent\\textbf{Keywords:} keyword1, keyword2, keyword3, keyword4, keyword5
\\end{abstract}

\\newpage
\\tableofcontents
\\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCTION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\\section{Introduction}
\\label{sec:introduction}

This section introduces the research topic and provides necessary background information. It should:

\\begin{itemize}
    \\item Establish the context and importance of the research
    \\item Review relevant prior work and identify gaps in knowledge
    \\item State the research objectives and hypotheses
    \\item Outline the structure of the paper
\\end{itemize}

% Example citation: As demonstrated by previous studies \\cite{example2023}, ...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% METHODOLOGY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\\section{Methodology}
\\label{sec:methodology}

This section describes the research methods and experimental procedures in sufficient detail for reproducibility.

\\subsection{Materials}
\\label{subsec:materials}

Describe the materials, reagents, and equipment used in the study.

\\subsection{Experimental Procedure}
\\label{subsec:procedure}

Detail the experimental steps and protocols followed.

\\subsection{Data Analysis}
\\label{subsec:analysis}

Explain the statistical methods and analytical techniques used to process the data.

% Example equation
\\begin{equation}
    E = mc^2
    \\label{eq:energy}
\\end{equation}

As shown in Equation~\\ref{eq:energy}, energy and mass are related.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RESULTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\\section{Results}
\\label{sec:results}

Present the findings of your research objectively.

\\subsection{Main Findings}
\\label{subsec:findings}

Describe the primary results of your experiments or analysis.

% Placeholder figure
\\begin{figure}[H]
    \\centering
    \\fbox{\\parbox{0.8\\textwidth}{\\centering\\vspace{3cm}[Figure Placeholder]\\\\Insert your figure here\\vspace{3cm}}}
    \\caption{Description of the figure content. This caption should explain what the figure shows and highlight key observations.}
    \\label{fig:example}
\\end{figure}

As shown in Figure~\\ref{fig:example}, the results demonstrate...

% Placeholder table
\\begin{table}[H]
    \\centering
    \\caption{Summary of experimental results.}
    \\label{tab:results}
    \\begin{tabular}{@{}lccc@{}}
        \\toprule
        \\textbf{Sample} & \\textbf{Parameter 1} & \\textbf{Parameter 2} & \\textbf{Parameter 3} \\\\
        \\midrule
        Sample A & 10.5 $\\pm$ 0.3 & 25.2 $\\pm$ 1.1 & 0.95 \\\\
        Sample B & 12.1 $\\pm$ 0.4 & 28.7 $\\pm$ 0.9 & 0.87 \\\\
        Sample C & 9.8 $\\pm$ 0.2 & 22.4 $\\pm$ 1.3 & 0.92 \\\\
        \\bottomrule
    \\end{tabular}
\\end{table}

Table~\\ref{tab:results} summarizes the key quantitative results.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DISCUSSION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\\section{Discussion}
\\label{sec:discussion}

Interpret your results and discuss their implications.

\\subsection{Interpretation of Results}
\\label{subsec:interpretation}

Explain what the results mean in the context of your research questions.

\\subsection{Comparison with Previous Work}
\\label{subsec:comparison}

Compare your findings with those reported in the literature.

\\subsection{Limitations}
\\label{subsec:limitations}

Acknowledge any limitations of your study and suggest how they might be addressed.

\\subsection{Future Directions}
\\label{subsec:future}

Propose future research directions based on your findings.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONCLUSION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\\section{Conclusion}
\\label{sec:conclusion}

Summarize the main findings and their significance:

\\begin{enumerate}
    \\item First key conclusion
    \\item Second key conclusion
    \\item Third key conclusion
\\end{enumerate}

The implications of this research extend to...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ACKNOWLEDGMENTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\\section*{Acknowledgments}

The authors thank [funding agency, collaborators, facilities] for their support. This work was supported by [grant number/funding source].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% REFERENCES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Uncomment and use for bibliography
% \\bibliographystyle{plainnat}
% \\bibliography{references}

% Placeholder references (remove when using .bib file)
\\begin{thebibliography}{9}

\\bibitem{example2023}
Author, A., Author, B., \\& Author, C. (2023).
\\textit{Title of the referenced paper}.
Journal Name, 45(3), 123-145.
\\href{https://doi.org/10.xxxx/xxxxx}{doi:10.xxxx/xxxxx}

\\bibitem{book2022}
Author, D. (2022).
\\textit{Title of Book}.
Publisher Name.

\\end{thebibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APPENDIX (if needed)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \\appendix
% \\section{Supplementary Material}
% \\label{app:supplementary}
% Additional data, derivations, or supporting information.

\\end{document}
`,
      type: 'tex',
      lastModified: new Date()
    };

    this.files.set('/main.tex', mainTex);
  }

  // ls - List files in directory
  ls(path: string = '/'): string[] {
    const result: string[] = [];
    for (const [filePath] of this.files) {
      if (path === '/' || filePath.startsWith(path)) {
        result.push(filePath);
      }
    }
    return result;
  }

  // read_file - Read file content
  readFile(path: string): LaTeXFile | null {
    return this.files.get(path) || null;
  }

  // write_file - Create or overwrite file
  writeFile(path: string, content: string, type?: 'tex' | 'bib' | 'cls' | 'sty' | 'image' | 'other'): void {
    const fileName = path.split('/').pop() || 'untitled';
    const fileType = type || this.inferFileType(fileName);
    
    this.files.set(path, {
      name: fileName,
      path,
      content,
      type: fileType,
      lastModified: new Date()
    });
  }

  // edit_file - Edit specific parts of a file
  editFile(path: string, oldContent: string, newContent: string): boolean {
    const file = this.files.get(path);
    if (!file) return false;
    
    if (file.content.includes(oldContent)) {
      file.content = file.content.replace(oldContent, newContent);
      file.lastModified = new Date();
      return true;
    }
    return false;
  }

  // glob - Find files matching pattern
  glob(pattern: string): string[] {
    const regex = new RegExp(pattern.replace(/\*/g, '.*').replace(/\?/g, '.'));
    return Array.from(this.files.keys()).filter(path => regex.test(path));
  }

  // grep - Search for text in files
  grep(searchText: string, filePattern?: string): Array<{ path: string; line: number; content: string }> {
    const results: Array<{ path: string; line: number; content: string }> = [];
    const filesToSearch = filePattern ? this.glob(filePattern) : Array.from(this.files.keys());
    
    for (const path of filesToSearch) {
      const file = this.files.get(path);
      if (!file) continue;
      
      const lines = file.content.split('\n');
      lines.forEach((line, index) => {
        if (line.includes(searchText)) {
          results.push({ path, line: index + 1, content: line });
        }
      });
    }
    return results;
  }

  // Delete file
  deleteFile(path: string): boolean {
    return this.files.delete(path);
  }

  // Get all files
  getAllFiles(): LaTeXFile[] {
    return Array.from(this.files.values());
  }

  // Clear all files
  clear(): void {
    this.files.clear();
    this.initializeDefaultProject();
  }

  // Set project name
  setProjectName(name: string): void {
    this.projectName = name;
  }

  getProjectName(): string {
    return this.projectName;
  }

  private inferFileType(fileName: string): 'tex' | 'bib' | 'cls' | 'sty' | 'image' | 'other' {
    const ext = fileName.split('.').pop()?.toLowerCase();
    switch (ext) {
      case 'tex': return 'tex';
      case 'bib': return 'bib';
      case 'cls': return 'cls';
      case 'sty': return 'sty';
      case 'png':
      case 'jpg':
      case 'jpeg':
      case 'pdf':
      case 'eps': return 'image';
      default: return 'other';
    }
  }
}

// ==========================================
// SwiftLaTeX Engine Integration
// Uses Netlify serverless function for CORS-free compilation
// Generates beautiful HTML preview for local development
// ==========================================

// SwiftLaTeX Engine Status enum
enum EngineStatus {
  Init = 1,
  Ready = 2,
  Busy = 3,
  Error = 4
}

class SwiftLaTeXEngine {
  private engineStatus: EngineStatus = EngineStatus.Init;
  private files: Map<string, string> = new Map();
  private mainFile: string = 'main.tex';

  async loadEngine(): Promise<void> {
    // No external resources needed - we compile via Netlify function or generate preview
    this.engineStatus = EngineStatus.Ready;
    console.log('LaTeX Engine ready (Netlify-based compilation)');
  }

  isReady(): boolean {
    return this.engineStatus === EngineStatus.Ready;
  }

  isEngineReady(): boolean {
    return this.isReady();
  }

  writeMemFSFile(filename: string, content: string): void {
    this.files.set(filename, content);
  }

  setEngineMainFile(filename: string): void {
    this.mainFile = filename;
  }

  flushCache(): void {
    this.files.clear();
  }

  async compile(files: LaTeXFile[], mainFile: string = 'main.tex'): Promise<CompileResult> {
    // Initialize if needed
    if (!this.isReady()) {
      await this.loadEngine();
    }

    // Find main file
    const mainFileData = files.find(f => f.path === mainFile || f.path === `/${mainFile}`);
    if (!mainFileData) {
      return {
        success: false,
        log: 'Main file not found',
        errors: [`Could not find main file: ${mainFile}`],
        warnings: []
      };
    }

    // Try Netlify function first (works in production, no CORS)
    try {
      const result = await this.tryNetlifyCompile(mainFileData.content, mainFile);
      if (result.success) {
        return result;
      }
    } catch (e) {
      console.log('Netlify function not available, trying direct API...');
    }

    // Try direct LaTeX API calls (may have CORS issues in some browsers)
    try {
      const result = await this.tryDirectLatexAPIs(mainFileData.content, mainFile);
      if (result.success) {
        return result;
      }
    } catch (e) {
      console.log('Direct LaTeX APIs failed:', e);
    }

    // Generate fallback preview with instructions
    return this.generatePreviewPdf(files, mainFile, '');
  }

  private async tryDirectLatexAPIs(content: string, filename: string): Promise<CompileResult> {
    // Try YtoTech LaTeX API (most reliable, supports CORS)
    try {
      const response = await fetch('https://latex.ytotech.com/builds/sync', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/pdf'
        },
        body: JSON.stringify({
          compiler: 'pdflatex',
          resources: [
            {
              path: filename || 'main.tex',
              main: true,
              content: content
            }
          ]
        })
      });

      if (response.ok) {
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('application/pdf')) {
          const pdfBuffer = await response.arrayBuffer();
          // Create a copy of the ArrayBuffer to avoid detachment issues
          const pdfArrayCopy = new Uint8Array(pdfBuffer).slice();
          const pdfBlob = new Blob([pdfArrayCopy], { type: 'application/pdf' });
          const pdfUrl = URL.createObjectURL(pdfBlob);

          return {
            success: true,
            pdfUrl,
            log: 'Compiled successfully with YtoTech LaTeX API',
            errors: [],
            warnings: []
          };
        } else {
          // API returned error in JSON format
          const errorData = await response.json().catch(() => ({}));
          console.log('YtoTech returned non-PDF:', errorData);
        }
      } else {
        const errorText = await response.text();
        console.log('YtoTech API error:', response.status, errorText);
      }
    } catch (e) {
      console.log('YtoTech API failed:', e);
    }

    // Try texlive.net as fallback (public TeXLive compiler)
    try {
      const formData = new FormData();
      formData.append('filecontents[]', content);
      formData.append('filename[]', filename || 'main.tex');
      formData.append('engine', 'pdflatex');
      formData.append('return', 'pdf');
      
      const response = await fetch('https://texlive.net/cgi-bin/latexcgi', {
        method: 'POST',
        body: formData
      });

      if (response.ok) {
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('application/pdf')) {
          const pdfBuffer = await response.arrayBuffer();
          // Create a copy of the ArrayBuffer to avoid detachment issues
          const pdfArrayCopy = new Uint8Array(pdfBuffer).slice();
          const pdfBlob = new Blob([pdfArrayCopy], { type: 'application/pdf' });
          const pdfUrl = URL.createObjectURL(pdfBlob);

          return {
            success: true,
            pdfUrl,
            log: 'Compiled successfully with TeXLive.net',
            errors: [],
            warnings: []
          };
        }
      }
    } catch (e) {
      console.log('texlive.net failed:', e);
    }

    throw new Error('All direct LaTeX APIs failed');
  }

  private async tryNetlifyCompile(content: string, filename: string): Promise<CompileResult> {
    // Use Netlify serverless function to compile (bypasses CORS)
    const netlifyUrl = window.location.hostname === 'localhost' 
      ? 'http://localhost:8888/.netlify/functions/compile_latex'
      : '/.netlify/functions/compile_latex';

    const response = await fetch(netlifyUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ content, filename })
    });

    if (!response.ok) {
      throw new Error(`Netlify function returned ${response.status}`);
    }

    const result = await response.json();
    
    if (result.success && result.pdf) {
      // Decode base64 PDF
      const pdfBinary = atob(result.pdf);
      const pdfArray = new Uint8Array(pdfBinary.length);
      for (let i = 0; i < pdfBinary.length; i++) {
        pdfArray[i] = pdfBinary.charCodeAt(i);
      }
      const pdfBlob = new Blob([pdfArray], { type: 'application/pdf' });
      const pdfUrl = URL.createObjectURL(pdfBlob);

      return {
        success: true,
        pdfUrl,
        log: result.log || 'Compiled successfully via Netlify',
        errors: [],
        warnings: []
      };
    }

    throw new Error(result.error || 'Compilation failed');
  }

  private generatePreviewPdf(files: LaTeXFile[], mainFile: string, errorMsg: string): CompileResult {
    // Create a beautiful HTML preview for when compilation fails
    const mainFileData = files.find(f => f.path === mainFile || f.path === `/${mainFile}`);
    
    // Extract title and content from LaTeX
    const content = mainFileData?.content || '';
    const titleMatch = content.match(/\\title\{([^}]+)\}/);
    const authorMatch = content.match(/\\author\{([^}]+)\}/);
    const title = titleMatch ? titleMatch[1].replace(/\\textbf\{([^}]+)\}/, '$1').replace(/\\\\/g, ' ') : 'LaTeX Document';
    const author = authorMatch ? authorMatch[1].replace(/\\\\/g, ', ') : '';
    
    // Extract sections for preview
    const sections: {title: string, content: string}[] = [];
    const sectionRegex = /\\section\{([^}]+)\}([^]*?)(?=\\section\{|\\end\{document\}|$)/g;
    let sectionMatch;
    while ((sectionMatch = sectionRegex.exec(content)) !== null) {
      sections.push({
        title: sectionMatch[1],
        content: sectionMatch[2].substring(0, 500).trim()
      });
    }
    
    // Escape HTML in content
    const escapeHtml = (text: string) => {
      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    };
    
    // Create an HTML preview that looks like a document
    const previewHtml = `
      <!DOCTYPE html>
      <html>
      <head>
        <title>${escapeHtml(title)}</title>
        <style>
          * { box-sizing: border-box; }
          body { 
            font-family: 'Georgia', 'Times New Roman', serif; 
            max-width: 800px; 
            margin: 0 auto; 
            padding: 40px 20px; 
            line-height: 1.8;
            background: #fff;
            color: #333;
          }
          .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 2px solid #333;
          }
          h1 { 
            font-size: 28px;
            margin-bottom: 10px;
            font-weight: normal;
          }
          .author {
            font-style: italic;
            color: #666;
            margin-bottom: 20px;
          }
          .preview-notice { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px; 
            border-radius: 10px; 
            margin: 30px 0;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
          }
          .preview-notice h3 {
            margin: 0 0 10px 0;
            font-size: 18px;
          }
          .preview-notice p {
            margin: 5px 0;
            opacity: 0.9;
          }
          .actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
          }
          .action-btn {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 6px;
          }
          .action-btn:hover {
            background: rgba(255,255,255,0.3);
          }
          .section {
            margin: 30px 0;
          }
          .section h2 {
            font-size: 20px;
            color: #444;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
            margin-bottom: 15px;
          }
          .section-preview {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #667eea;
            font-style: italic;
            color: #555;
          }
          .source-code {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
          }
          .source-code .comment { color: #6a9955; }
          .source-code .command { color: #569cd6; }
          .source-code .brace { color: #ffd700; }
          .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            text-align: center;
            color: #888;
            font-size: 14px;
          }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>${escapeHtml(title)}</h1>
          ${author ? `<div class="author">${escapeHtml(author)}</div>` : ''}
        </div>
        
        <div class="preview-notice">
          <h3>ðŸ“„ Document Preview</h3>
          <p>This is a preview of your LaTeX document. In-browser compilation is not available in development mode.</p>
          <p style="font-size: 12px; opacity: 0.8;">After deployment, compilation will work automatically.</p>
          <div class="actions">
            <a href="https://www.overleaf.com/project" target="_blank" class="action-btn">
              ðŸš€ Open Overleaf
            </a>
            <button onclick="navigator.clipboard.writeText(document.getElementById('latex-source').textContent).then(() => alert('Copied!'))" class="action-btn">
              ðŸ“‹ Copy Source
            </button>
          </div>
        </div>

        ${sections.length > 0 ? `
        <div class="section">
          <h2>Document Structure</h2>
          ${sections.map(s => `
            <div style="margin: 15px 0;">
              <strong>${escapeHtml(s.title)}</strong>
              <div class="section-preview">${escapeHtml(s.content.substring(0, 200))}${s.content.length > 200 ? '...' : ''}</div>
            </div>
          `).join('')}
        </div>
      ` : ''}
      
      <div class="section">
        <h2>LaTeX Source Code</h2>
        <div class="source-code" id="latex-source">${escapeHtml(content)}</div>
      </div>
      
      <div class="footer">
        Generated by LaTeX Document Agent â€¢ Use Overleaf or local LaTeX for PDF output
      </div>
    </body>
    </html>
  `;

    // In development mode, don't set pdfUrl - let the UI show compile message
    // This prevents react-pdf from trying to render HTML as PDF
    return {
      success: false,
      // Don't set pdfUrl here since it's HTML, not PDF
      // The UI will show proper guidance instead
      log: `LaTeX Compilation Services Unavailable\n\nAll online LaTeX compilation services are currently unavailable.\n\nTo compile your document:\n1. Click "Copy Source" to copy your LaTeX code\n2. Paste into Overleaf (https://www.overleaf.com)\n3. Compile there for PDF output\n\nAlternatively, wait a moment and try compiling again.`,
      errors: ['LaTeX compilation services temporarily unavailable'],
      warnings: ['Use Overleaf or local LaTeX installation for PDF output']
    };
  }

  private extractErrors(log: string): string[] {
    const errors: string[] = [];
    const errorPatterns = [
      /^! (.+)$/gm,
      /^l\.(\d+) (.+)$/gm,
      /Error: (.+)/gi
    ];

    for (const pattern of errorPatterns) {
      let match;
      while ((match = pattern.exec(log)) !== null) {
        errors.push(match[0]);
      }
    }
    return [...new Set(errors)];
  }  private extractWarnings(log: string): string[] {
    const warnings: string[] = [];
    const warningPatterns = [
      /Warning: (.+)/gi,
      /Overfull \\hbox (.+)/g,
      /Underfull \\hbox (.+)/g
    ];

    for (const pattern of warningPatterns) {
      let match;
      while ((match = pattern.exec(log)) !== null) {
        warnings.push(match[0]);
      }
    }
    return [...new Set(warnings)];
  }

  closeEngine(): void {
    // No worker to terminate - just reset state
    this.engineStatus = EngineStatus.Init;
    this.files.clear();
  }
}

// ==========================================
// Todo List / Planning System
// ==========================================

class TodoManager {
  private todos: LaTeXTodoItem[] = [];

  // write_todos - Update the entire todo list
  writeTodos(todos: LaTeXTodoItem[]): void {
    this.todos = todos;
  }

  // Add a new todo
  addTodo(title: string, description?: string, priority: 'high' | 'medium' | 'low' = 'medium'): LaTeXTodoItem {
    const todo: LaTeXTodoItem = {
      id: `todo-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      title,
      description,
      status: 'pending',
      priority
    };
    this.todos.push(todo);
    return todo;
  }

  // Update todo status
  updateTodoStatus(id: string, status: 'pending' | 'in-progress' | 'completed'): boolean {
    const todo = this.todos.find(t => t.id === id);
    if (todo) {
      todo.status = status;
      return true;
    }
    return false;
  }

  // Get all todos
  getTodos(): LaTeXTodoItem[] {
    return [...this.todos];
  }

  // Get todos by status
  getTodosByStatus(status: 'pending' | 'in-progress' | 'completed'): LaTeXTodoItem[] {
    return this.todos.filter(t => t.status === status);
  }

  // Clear all todos
  clear(): void {
    this.todos = [];
  }

  // Generate a summary of todos
  getSummary(): string {
    const pending = this.todos.filter(t => t.status === 'pending').length;
    const inProgress = this.todos.filter(t => t.status === 'in-progress').length;
    const completed = this.todos.filter(t => t.status === 'completed').length;
    return `Tasks: ${completed}/${this.todos.length} completed, ${inProgress} in progress, ${pending} pending`;
  }
}

// ==========================================
// Subagent Definitions
// ==========================================

const subagents: Map<string, SubAgent> = new Map([
  ['document-architect', {
    name: 'document-architect',
    description: 'Specialized in planning document structure, creating outlines, and organizing content hierarchy. Use for initial document planning.',
    systemPrompt: `You are a Document Architect subagent. Your role is to:
1. Analyze the document requirements
2. Create a detailed outline with sections and subsections
3. Suggest appropriate LaTeX document class and packages
4. Define the logical flow of content
5. Identify what figures, tables, and equations are needed

Always output a structured plan that can be executed step by step.`,
    tools: ['write_todos', 'write_file']
  }],
  
  ['content-writer', {
    name: 'content-writer',
    description: 'Expert at writing high-quality academic and technical content. Use for drafting sections, paragraphs, and explanations.',
    systemPrompt: `You are a Content Writer subagent. Your role is to:
1. Write clear, well-structured content
2. Use appropriate academic tone and style
3. Include proper citations and references
4. Create coherent paragraphs with good transitions
5. Ensure technical accuracy

Write in LaTeX format with proper commands and environments.`,
    tools: ['write_file', 'edit_file', 'read_file']
  }],
  
  ['math-typesetter', {
    name: 'math-typesetter',
    description: 'Specialized in mathematical content, equations, proofs, and theorems. Use for any mathematical notation.',
    systemPrompt: `You are a Math Typesetter subagent. Your role is to:
1. Format mathematical equations correctly in LaTeX
2. Use appropriate math environments (equation, align, gather, etc.)
3. Create proper theorem, lemma, and proof environments
4. Handle complex mathematical notation
5. Ensure mathematical correctness and clarity

Use proper LaTeX math packages like amsmath, amssymb, amsthm.`,
    tools: ['write_file', 'edit_file']
  }],
  
  ['figure-creator', {
    name: 'figure-creator',
    description: 'Creates figures, diagrams, and visualizations using TikZ and other LaTeX graphics packages.',
    systemPrompt: `You are a Figure Creator subagent. Your role is to:
1. Create TikZ diagrams and figures
2. Design flowcharts and block diagrams
3. Create plots and graphs using pgfplots
4. Draw scientific illustrations
5. Format figure captions and labels properly

Use tikz, pgfplots, and other graphics packages effectively.`,
    tools: ['write_file', 'edit_file']
  }],
  
  ['table-formatter', {
    name: 'table-formatter',
    description: 'Expert at creating and formatting tables in LaTeX using booktabs and other packages.',
    systemPrompt: `You are a Table Formatter subagent. Your role is to:
1. Create well-formatted tables using booktabs
2. Handle complex multi-column and multi-row layouts
3. Format numerical data properly
4. Add appropriate captions and labels
5. Ensure tables are accessible and clear

Use booktabs, tabularx, longtable packages as needed.`,
    tools: ['write_file', 'edit_file']
  }],
  
  ['bibliography-manager', {
    name: 'bibliography-manager',
    description: 'Manages references, citations, and bibliographies using BibTeX/BibLaTeX.',
    systemPrompt: `You are a Bibliography Manager subagent. Your role is to:
1. Create and maintain .bib files
2. Format citations correctly
3. Choose appropriate bibliography styles
4. Handle in-text citations
5. Organize references by category if needed

Use biblatex or bibtex with appropriate style files.`,
    tools: ['write_file', 'edit_file', 'read_file']
  }],
  
  ['latex-debugger', {
    name: 'latex-debugger',
    description: 'Analyzes and fixes LaTeX compilation errors and warnings.',
    systemPrompt: `You are a LaTeX Debugger subagent. Your role is to:
1. Analyze compilation logs for errors
2. Identify the root cause of problems
3. Suggest specific fixes
4. Check for common LaTeX issues
5. Verify package compatibility

Provide clear, actionable fixes for any LaTeX issues.`,
    tools: ['read_file', 'edit_file', 'grep']
  }]
]);

// ==========================================
// Tool Definitions
// ==========================================

interface ToolDefinition {
  name: string;
  description: string;
  execute: (params: any, context: AgentContext) => Promise<string>;
}

interface AgentContext {
  fileSystem: LaTeXFileSystem;
  todoManager: TodoManager;
  engine: SwiftLaTeXEngine;
  genAI: GoogleGenAI;
}

const tools: Map<string, ToolDefinition> = new Map([
  // File System Tools
  ['ls', {
    name: 'ls',
    description: 'List files in the project directory',
    execute: async (params: { path?: string }, context) => {
      const files = context.fileSystem.ls(params.path || '/');
      return JSON.stringify({ files });
    }
  }],
  
  ['read_file', {
    name: 'read_file',
    description: 'Read the contents of a file',
    execute: async (params: { path: string; startLine?: number; endLine?: number }, context) => {
      const file = context.fileSystem.readFile(params.path);
      if (!file) {
        return JSON.stringify({ error: `File not found: ${params.path}` });
      }
      
      let content = file.content;
      if (params.startLine || params.endLine) {
        const lines = content.split('\n');
        const start = (params.startLine || 1) - 1;
        const end = params.endLine || lines.length;
        content = lines.slice(start, end).join('\n');
      }
      
      return JSON.stringify({ path: params.path, content, type: file.type });
    }
  }],
  
  ['write_file', {
    name: 'write_file',
    description: 'Create or overwrite a file with content',
    execute: async (params: { path: string; content: string }, context) => {
      context.fileSystem.writeFile(params.path, params.content);
      return JSON.stringify({ success: true, path: params.path, message: `File written: ${params.path}` });
    }
  }],
  
  ['edit_file', {
    name: 'edit_file',
    description: 'Edit a specific part of a file by replacing old content with new content',
    execute: async (params: { path: string; oldContent: string; newContent: string }, context) => {
      const success = context.fileSystem.editFile(params.path, params.oldContent, params.newContent);
      if (success) {
        return JSON.stringify({ success: true, message: `File edited: ${params.path}` });
      }
      return JSON.stringify({ error: `Could not find content to replace in ${params.path}` });
    }
  }],
  
  ['glob', {
    name: 'glob',
    description: 'Find files matching a pattern (e.g., "*.tex" or "chapters/*.tex")',
    execute: async (params: { pattern: string }, context) => {
      const files = context.fileSystem.glob(params.pattern);
      return JSON.stringify({ files });
    }
  }],
  
  ['grep', {
    name: 'grep',
    description: 'Search for text within files',
    execute: async (params: { text: string; pattern?: string }, context) => {
      const results = context.fileSystem.grep(params.text, params.pattern);
      return JSON.stringify({ results });
    }
  }],
  
  // Planning Tools
  ['write_todos', {
    name: 'write_todos',
    description: 'Create or update the task list for document creation. Use "todos" array with objects containing title, description, status, priority.',
    execute: async (params: { todos?: Array<{ title: string; description?: string; status?: string; priority?: string }>; tasks?: Array<{ title?: string; description?: string; status?: string; priority?: string } | string> }, context) => {
      // Support both 'todos' and 'tasks' parameter names, and handle string arrays
      const inputItems = params.todos || params.tasks || [];
      const todos: LaTeXTodoItem[] = inputItems.map((t, i) => {
        // Handle both object and string formats
        if (typeof t === 'string') {
          return {
            id: `todo-${Date.now()}-${i}`,
            title: t,
            description: undefined,
            status: 'pending' as const,
            priority: 'medium' as const
          };
        }
        return {
          id: `todo-${Date.now()}-${i}`,
          title: t.title || t.description || `Task ${i + 1}`,
          description: t.description,
          status: (t.status as 'pending' | 'in-progress' | 'completed') || 'pending',
          priority: (t.priority as 'high' | 'medium' | 'low') || 'medium'
        };
      });
      context.todoManager.writeTodos(todos);
      return JSON.stringify({ success: true, todos, summary: context.todoManager.getSummary() });
    }
  }],
  
  ['update_todo', {
    name: 'update_todo',
    description: 'Update the status of a specific task',
    execute: async (params: { id: string; status: 'pending' | 'in-progress' | 'completed' }, context) => {
      const success = context.todoManager.updateTodoStatus(params.id, params.status);
      return JSON.stringify({ success, summary: context.todoManager.getSummary() });
    }
  }],
  
  // Compilation Tools
  ['compile', {
    name: 'compile',
    description: 'Compile the LaTeX document to PDF',
    execute: async (params: { mainFile?: string }, context) => {
      const files = context.fileSystem.getAllFiles();
      const result = await context.engine.compile(files, params.mainFile || 'main.tex');
      return JSON.stringify({
        success: result.success,
        errors: result.errors,
        warnings: result.warnings,
        message: result.success ? 'Compilation successful!' : 'Compilation failed with errors'
      });
    }
  }],
  
  // Document Generation Tools
  ['generate_section', {
    name: 'generate_section',
    description: 'Generate content for a document section using AI',
    execute: async (params: { sectionTitle: string; requirements: string; style?: string }, context) => {
      const prompt = `Generate LaTeX content for a section titled "${params.sectionTitle}".

Requirements: ${params.requirements}
Style: ${params.style || 'academic'}

Output ONLY the LaTeX content for this section, starting with \\section{${params.sectionTitle}} and including all relevant subsections, text, equations, and figures as needed. Use proper LaTeX formatting.`;

      try {
        const response = await context.genAI.models.generateContent({
          model: 'gemini-2.0-flash',
          contents: [{ role: 'user', parts: [{ text: prompt }] }]
        });
        
        const content = response.text || '';
        return JSON.stringify({ success: true, content });
      } catch (err) {
        return JSON.stringify({ error: `Failed to generate section: ${err}` });
      }
    }
  }],
  
  ['suggest_packages', {
    name: 'suggest_packages',
    description: 'Suggest LaTeX packages based on document requirements',
    execute: async (params: { requirements: string }, context) => {
      const prompt = `Based on these document requirements, suggest the most appropriate LaTeX packages:

Requirements: ${params.requirements}

Return a JSON object with:
- packages: array of {name: string, purpose: string, usage: string}
- preamble: the complete preamble code`;

      try {
        const response = await context.genAI.models.generateContent({
          model: 'gemini-2.0-flash',
          contents: [{ role: 'user', parts: [{ text: prompt }] }]
        });
        
        return response.text || JSON.stringify({ packages: [] });
      } catch (err) {
        return JSON.stringify({ error: `Failed to suggest packages: ${err}` });
      }
    }
  }]
]);

// ==========================================
// Main LaTeX Agent Class
// ==========================================

class LaTeXAgent {
  private genAI: GoogleGenAI | null = null;
  private isInitialized = false;
  private fileSystem: LaTeXFileSystem;
  private todoManager: TodoManager;
  private engine: SwiftLaTeXEngine;
  private conversationHistory: Array<{ role: string; content: string }> = [];
  private currentSubagent: string | null = null;

  constructor() {
    this.fileSystem = new LaTeXFileSystem();
    this.todoManager = new TodoManager();
    this.engine = new SwiftLaTeXEngine();
  }

  async initialize(): Promise<void> {
    if (this.isInitialized) return;

    try {
      if (!isGeminiInitialized()) {
        await initializeGeminiWithFirebaseKey();
      }

      const apiKey = await getSharedGeminiApiKey();
      if (!apiKey) {
        throw new Error('No Gemini API key available');
      }

      this.genAI = new GoogleGenAI({ apiKey });
      this.isInitialized = true;
      console.log('âœ… LaTeX Agent initialized successfully');
    } catch (err) {
      console.error('âŒ Failed to initialize LaTeX Agent:', err);
      throw err;
    }
  }

  private getContext(): AgentContext {
    if (!this.genAI) throw new Error('Agent not initialized');
    return {
      fileSystem: this.fileSystem,
      todoManager: this.todoManager,
      engine: this.engine,
      genAI: this.genAI
    };
  }

  private getSystemPrompt(): string {
    return `You are an advanced LaTeX Document Agent with deep capabilities for creating complete, professional documents.

## Your Core Capabilities

### ðŸ“‹ Planning (write_todos)
For any document request, ALWAYS start by creating a plan using the write_todos tool. Break down the document creation into steps.

IMPORTANT: Use the correct format for write_todos:
[TOOL: write_todos]
{"todos": [{"title": "Step 1 title", "description": "Details"}, {"title": "Step 2 title", "description": "Details"}]}
[/TOOL]

### ðŸ“ File System Tools
You have access to a complete file system for managing document files:
- **ls**: List files in directory
- **read_file**: Read file contents
- **write_file**: Create or overwrite files - use {"path": "/filename.tex", "content": "..."}
- **edit_file**: Make targeted edits to existing files
- **glob**: Find files by pattern
- **grep**: Search for text in files

### ðŸ‘¥ Subagents
You can delegate specific tasks to specialized subagents:
${Array.from(subagents.values()).map(s => `- **${s.name}**: ${s.description}`).join('\n')}

To delegate to a subagent, use:
[DELEGATE: subagent-name]
Task description here
[/DELEGATE]

### ðŸ› ï¸ Tools
${Array.from(tools.values()).map(t => `- **${t.name}**: ${t.description}`).join('\n')}

To use a tool:
[TOOL: tool_name]
{"param1": "value1"}
[/TOOL]

### ðŸ“„ Document Standards
When creating LaTeX documents:
1. Use appropriate document classes (article, report, book, beamer)
2. Include necessary packages with comments explaining purpose
3. Create modular structure with separate files for chapters/sections
4. Use proper figure, table, and equation environments
5. Follow LaTeX best practices for formatting
6. Add bibliography using BibTeX when references are needed

### Current Project State
Files: ${this.fileSystem.ls('/').join(', ') || 'main.tex'}
Todos: ${this.todoManager.getSummary()}

## Response Format
Always structure your response:
1. Acknowledge the request
2. Create/update plan (if complex task)
3. Execute tools as needed
4. Show progress on todos
5. Provide next steps or ask clarifying questions`;
  }

  async chat(message: string): Promise<LaTeXAgentMessage> {
    if (!this.isInitialized || !this.genAI) {
      await this.initialize();
    }

    if (!this.genAI) throw new Error('Agent not initialized');

    try {
      // Build conversation messages
      const messages = [
        { role: 'user', parts: [{ text: this.getSystemPrompt() }] },
        ...this.conversationHistory.map(h => ({
          role: h.role === 'assistant' ? 'model' : 'user',
          parts: [{ text: h.content }]
        })),
        { role: 'user', parts: [{ text: message }] }
      ];

      // Get response from Gemini
      const response = await this.genAI.models.generateContent({
        model: 'gemini-2.0-flash',
        contents: messages
      });

      let responseText = response.text || '';

      // Process tool calls
      const toolResults = await this.processToolCalls(responseText);
      
      // Process subagent delegations
      const delegationResults = await this.processDelegations(responseText);

      // Get files modified and tools used
      const filesModified = this.extractModifiedFiles(responseText, toolResults);
      const toolsUsed = this.extractToolsUsed(responseText);

      // Update conversation history
      this.conversationHistory.push({ role: 'user', content: message });
      this.conversationHistory.push({ role: 'assistant', content: responseText });

      // Append tool results to response
      if (toolResults.length > 0) {
        responseText += '\n\n---\n**Tool Results:**\n' + toolResults.map(r => r.result).join('\n\n');
      }

      if (delegationResults.length > 0) {
        responseText += '\n\n---\n**Subagent Results:**\n' + delegationResults.map(r => r.result).join('\n\n');
      }

      return {
        role: 'assistant',
        content: responseText,
        timestamp: new Date(),
        todos: this.todoManager.getTodos(),
        filesModified: filesModified.length > 0 ? filesModified : undefined,
        subagentUsed: delegationResults.length > 0 ? delegationResults[0].subagent : undefined,
        toolsUsed: toolsUsed.length > 0 ? toolsUsed : undefined
      };
    } catch (err) {
      console.error('Chat error:', err);
      return {
        role: 'assistant',
        content: `Error processing request: ${err instanceof Error ? err.message : String(err)}`,
        timestamp: new Date()
      };
    }
  }

  async *stream(message: string): AsyncGenerator<string, void, unknown> {
    if (!this.isInitialized || !this.genAI) {
      await this.initialize();
    }

    if (!this.genAI) throw new Error('Agent not initialized');

    try {
      const messages = [
        { role: 'user', parts: [{ text: this.getSystemPrompt() }] },
        ...this.conversationHistory.map(h => ({
          role: h.role === 'assistant' ? 'model' : 'user',
          parts: [{ text: h.content }]
        })),
        { role: 'user', parts: [{ text: message }] }
      ];

      const response = await this.genAI.models.generateContentStream({
        model: 'gemini-2.0-flash',
        contents: messages
      });

      let fullResponse = '';
      for await (const chunk of response) {
        const text = chunk.text || '';
        fullResponse += text;
        yield text;
      }

      // Process tools after streaming
      const toolResults = await this.processToolCalls(fullResponse);
      if (toolResults.length > 0) {
        yield '\n\n---\n**Executing tools...**\n\n';
        for (const result of toolResults) {
          yield `âœ… **${result.tool}**: ${result.result}\n\n`;
        }
      }

      // Update conversation history
      this.conversationHistory.push({ role: 'user', content: message });
      this.conversationHistory.push({ role: 'assistant', content: fullResponse });

    } catch (err) {
      yield `\n\nError: ${err instanceof Error ? err.message : String(err)}`;
    }
  }

  private async processToolCalls(text: string): Promise<Array<{ tool: string; result: string }>> {
    const results: Array<{ tool: string; result: string }> = [];
    const toolPattern = /\[TOOL:\s*(\w+)\]\s*([\s\S]*?)\s*\[\/TOOL\]/g;
    
    let match;
    while ((match = toolPattern.exec(text)) !== null) {
      const toolName = match[1];
      const paramsStr = match[2].trim();
      
      const tool = tools.get(toolName);
      if (tool) {
        try {
          const params = JSON.parse(paramsStr);
          const result = await tool.execute(params, this.getContext());
          results.push({ tool: toolName, result });
        } catch (err) {
          results.push({ tool: toolName, result: `Error: ${err}` });
        }
      }
    }
    
    return results;
  }

  private async processDelegations(text: string): Promise<Array<{ subagent: string; result: string }>> {
    const results: Array<{ subagent: string; result: string }> = [];
    const delegatePattern = /\[DELEGATE:\s*([\w-]+)\]\s*([\s\S]*?)\s*\[\/DELEGATE\]/g;
    
    let match;
    while ((match = delegatePattern.exec(text)) !== null) {
      const subagentName = match[1];
      const task = match[2].trim();
      
      const subagent = subagents.get(subagentName);
      if (subagent && this.genAI) {
        try {
          const response = await this.genAI.models.generateContent({
            model: 'gemini-2.0-flash',
            contents: [
              { role: 'user', parts: [{ text: subagent.systemPrompt }] },
              { role: 'user', parts: [{ text: `Task: ${task}\n\nCurrent files: ${this.fileSystem.ls('/').join(', ')}` }] }
            ]
          });
          
          const result = response.text || 'No response from subagent';
          results.push({ subagent: subagentName, result });
          this.currentSubagent = subagentName;
        } catch (err) {
          results.push({ subagent: subagentName, result: `Error: ${err}` });
        }
      }
    }
    
    return results;
  }

  private extractModifiedFiles(text: string, toolResults: Array<{ tool: string; result: string }>): string[] {
    const files: string[] = [];
    
    for (const result of toolResults) {
      if (result.tool === 'write_file' || result.tool === 'edit_file') {
        try {
          const parsed = JSON.parse(result.result);
          if (parsed.path) files.push(parsed.path);
        } catch {}
      }
    }
    
    return [...new Set(files)];
  }

  private extractToolsUsed(text: string): string[] {
    const tools: string[] = [];
    const pattern = /\[TOOL:\s*(\w+)\]/g;
    
    let match;
    while ((match = pattern.exec(text)) !== null) {
      tools.push(match[1]);
    }
    
    return [...new Set(tools)];
  }

  // Compile the current project
  async compile(mainFile?: string): Promise<CompileResult> {
    const files = this.fileSystem.getAllFiles();
    return this.engine.compile(files, mainFile);
  }

  // File system access
  getFiles(): LaTeXFile[] {
    return this.fileSystem.getAllFiles();
  }

  getFile(path: string): LaTeXFile | null {
    return this.fileSystem.readFile(path);
  }

  writeFile(path: string, content: string): void {
    this.fileSystem.writeFile(path, content);
  }

  deleteFile(path: string): boolean {
    return this.fileSystem.deleteFile(path);
  }

  // Todo access
  getTodos(): LaTeXTodoItem[] {
    return this.todoManager.getTodos();
  }

  // Get available subagents
  getSubagents(): Array<{ name: string; description: string }> {
    return Array.from(subagents.values()).map(s => ({
      name: s.name,
      description: s.description
    }));
  }

  // Get available tools
  getTools(): Array<{ name: string; description: string }> {
    return Array.from(tools.values()).map(t => ({
      name: t.name,
      description: t.description
    }));
  }

  // Reset agent
  reset(): void {
    this.conversationHistory = [];
    this.fileSystem.clear();
    this.todoManager.clear();
    this.currentSubagent = null;
  }

  // Check if engine is ready
  isEngineReady(): boolean {
    return this.engine.isEngineReady();
  }

  // Load the LaTeX engine
  async loadEngine(): Promise<void> {
    await this.engine.loadEngine();
  }
}

// ==========================================
// Singleton Instance and Exports
// ==========================================

let agentInstance: LaTeXAgent | null = null;

export const getLatexAgent = (): LaTeXAgent => {
  if (!agentInstance) {
    agentInstance = new LaTeXAgent();
  }
  return agentInstance;
};

export const initializeLatexAgent = async (): Promise<void> => {
  const agent = getLatexAgent();
  await agent.initialize();
};

export const chatWithLatexAgent = async (message: string): Promise<LaTeXAgentMessage> => {
  const agent = getLatexAgent();
  return agent.chat(message);
};

export const streamFromLatexAgent = (message: string): AsyncGenerator<string, void, unknown> => {
  const agent = getLatexAgent();
  return agent.stream(message);
};

export const compileLatexProject = async (mainFile?: string): Promise<CompileResult> => {
  const agent = getLatexAgent();
  return agent.compile(mainFile);
};

export const getLatexFiles = (): LaTeXFile[] => {
  const agent = getLatexAgent();
  return agent.getFiles();
};

export const getLatexFile = (path: string): LaTeXFile | null => {
  const agent = getLatexAgent();
  return agent.getFile(path);
};

export const writeLatexFile = (path: string, content: string): void => {
  const agent = getLatexAgent();
  agent.writeFile(path, content);
};

export const deleteLatexFile = (path: string): boolean => {
  const agent = getLatexAgent();
  return agent.deleteFile(path);
};

export const getLatexTodos = (): LaTeXTodoItem[] => {
  const agent = getLatexAgent();
  return agent.getTodos();
};

export const getLatexSubagents = (): Array<{ name: string; description: string }> => {
  const agent = getLatexAgent();
  return agent.getSubagents();
};

export const getLatexTools = (): Array<{ name: string; description: string }> => {
  const agent = getLatexAgent();
  return agent.getTools();
};

export const resetLatexAgent = (): void => {
  const agent = getLatexAgent();
  agent.reset();
};

export const isLatexEngineReady = (): boolean => {
  const agent = getLatexAgent();
  return agent.isEngineReady();
};

export const loadLatexEngine = async (): Promise<void> => {
  const agent = getLatexAgent();
  await agent.loadEngine();
};
